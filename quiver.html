<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quiver Mutation Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* ---- header bar ---- */
        .header {
            display: flex;
            align-items: center;
            gap: 24px;
            padding: 12px 24px;
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
        }
        .header h1 { font-size: 20px; color: #2c3e50; white-space: nowrap; }
        .header select {
            padding: 6px 10px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: #fff;
            cursor: pointer;
        }
        .header label { font-size: 14px; color: #34495e; }
        .quiver-picker { display: flex; gap: 0; }
        .quiver-picker input[type="radio"] { display: none; }
        .quiver-picker label {
            padding: 5px 14px;
            font-size: 13px;
            color: #555;
            background: #f5f5f5;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.15s;
            user-select: none;
        }
        .quiver-picker label:first-of-type { border-radius: 5px 0 0 5px; }
        .quiver-picker label:last-of-type { border-radius: 0 5px 5px 0; }
        .quiver-picker label:not(:first-of-type) { border-left: none; }
        .quiver-picker input[type="radio"]:checked + label,
        .quiver-picker label.active {
            background: #3498db;
            color: #fff;
            border-color: #3498db;
        }
        .quiver-picker label sub { font-size: 0.75em; }
        .header .sep { width: 1px; height: 24px; background: #ddd; }
        .quiver-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .vector-extras {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
        }
        .vec-input {
            width: 36px;
            padding: 3px 4px;
            font-size: 13px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .vec-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .vec-input { -moz-appearance: textfield; }
        .vec-label { font-weight: bold; margin-left: 6px; }
        .random-extras {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .header button {
            padding: 6px 18px;
            font-size: 14px;
            font-weight: 500;
            background: #3498db;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            white-space: nowrap;
        }
        .header button:hover { background: #2980b9; }
        .header button:active { transform: scale(0.97); }

        /* ---- tabs ---- */
        .tab-bar {
            display: flex;
            gap: 0;
            padding: 0 24px;
            background: #fff;
            border-bottom: 2px solid #e0e0e0;
            flex-shrink: 0;
        }
        .tab-btn {
            padding: 10px 28px;
            font-size: 14px;
            font-weight: 500;
            background: none;
            color: #7f8c8d;
            border: none;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            cursor: pointer;
            transition: color 0.15s, border-color 0.15s;
            border-radius: 0;
        }
        .tab-btn:hover { color: #2c3e50; background: none; }
        .tab-btn.active {
            color: #2c3e50;
            border-bottom-color: #3498db;
            background: none;
        }

        /* ---- tab content ---- */
        .tab-content { flex: 1; overflow: hidden; display: none; }
        .tab-content.active { display: flex; }

        /* -- quiver tab -- */
        #tabQuiver {
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 20px;
        }
        #tabQuiver canvas {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        .matrix-display {
            font-family: 'Courier New', monospace;
            font-size: 15px;
            color: #34495e;
            background: #fff;
            padding: 14px 24px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.06);
            text-align: center;
        }
        .matrix-display .label {
            font-family: 'Segoe UI', sans-serif;
            font-size: 13px;
            color: #7f8c8d;
            margin-bottom: 6px;
        }
        .matrix-row { line-height: 1.6; }
        .matrix-row span { display: inline-block; width: 36px; text-align: right; }

        /* -- mutation graph tab -- */
        #tabMG {
            flex-direction: column;
        }
        .mg-toolbar {
            display: flex;
            align-items: center;
            gap: 18px;
            padding: 8px 20px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }
        .depth-control {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: #34495e;
        }
        .depth-control select {
            padding: 5px 10px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: #fff;
            cursor: pointer;
        }
        .mg-info { font-size: 13px; color: #7f8c8d; }
        .mg-info .warn { color: #e67e22; font-weight: 500; }
        .mg-legend {
            display: flex;
            gap: 14px;
            font-size: 12px;
            color: #555;
            margin-left: auto;
        }
        .mg-legend-item { display: flex; align-items: center; gap: 4px; }
        .mg-legend-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        .mg-hint { font-size: 11px; color: #aaa; }
        .rotate-control {
            display: flex; align-items: center; gap: 5px;
            font-size: 13px; color: #34495e;
        }
        .rotate-control input[type="range"] {
            width: 80px; cursor: pointer;
        }
        .rotate-control .angle-label {
            font-size: 11px; color: #7f8c8d; min-width: 28px;
        }
        .toggle-control {
            display: flex; align-items: center; gap: 6px;
            font-size: 13px; color: #34495e;
        }
        .toggle-switch {
            position: relative; width: 34px; height: 18px; cursor: pointer;
        }
        .toggle-switch input { display: none; }
        .toggle-switch .slider {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: #ccc; border-radius: 9px; transition: 0.2s;
        }
        .toggle-switch .slider::before {
            content: ''; position: absolute; width: 14px; height: 14px;
            left: 2px; bottom: 2px; background: #fff; border-radius: 50%;
            transition: 0.2s;
        }
        .toggle-switch input:checked + .slider { background: #3498db; }
        .toggle-switch input:checked + .slider::before { transform: translateX(16px); }
        .mg-canvas-wrap {
            flex: 1;
            overflow: hidden;
            padding: 0 12px 10px 12px;
            position: relative;
        }
        .export-container {
            position: absolute;
            bottom: 20px;
            right: 22px;
            z-index: 10;
        }
        .export-btn {
            padding: 5px 14px;
            font-size: 12px;
            background: rgba(127,140,141,0.85);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .export-btn:hover { background: rgba(90,100,100,0.95); }
        .export-popover {
            position: absolute;
            bottom: calc(100% + 8px);
            right: 0;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 12px 14px;
            min-width: 180px;
            font-size: 13px;
            color: #333;
        }
        .export-popover .ep-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }
        .export-popover .ep-row { margin-bottom: 10px; }
        .export-popover .ep-row:last-child { margin-bottom: 0; }
        .ep-options {
            display: flex;
            gap: 0;
        }
        .ep-options label {
            flex: 1;
            text-align: center;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1.5px solid #ddd;
            background: #f8f8f8;
            color: #555;
            transition: all 0.1s;
            user-select: none;
        }
        .ep-options label:first-child { border-radius: 4px 0 0 4px; }
        .ep-options label:last-child { border-radius: 0 4px 4px 0; }
        .ep-options label:not(:first-child) { border-left: none; }
        .ep-options input { display: none; }
        .ep-options input:checked + span {
            color: #fff;
        }
        .ep-options label:has(input:checked) {
            background: #3498db;
            border-color: #3498db;
            color: #fff;
        }
        .ep-options label:has(input:checked) + label { border-left-color: #3498db; }
        .ep-go {
            width: 100%;
            padding: 6px 0;
            font-size: 13px;
            font-weight: 500;
            background: #3498db;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.15s;
            margin-top: 2px;
        }
        .ep-go:hover { background: #2980b9; }
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.88);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            gap: 12px;
            transition: opacity 0.15s;
        }
        .loading-overlay .loading-text {
            font-size: 14px;
            color: #34495e;
            font-weight: 500;
        }
        .loading-overlay .loading-bar-track {
            width: 220px;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }
        .loading-overlay .loading-bar-fill {
            height: 100%;
            background: #3498db;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        #mgCanvas {
            cursor: grab;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            display: block;
            touch-action: none;
        }
        #mgCanvas:active { cursor: grabbing; }

        /* -- exchange graph tab -- */
        #tabEG { flex-direction: column; }
        .eg-toolbar {
            display: flex; align-items: center; gap: 18px;
            padding: 8px 20px; flex-shrink: 0; flex-wrap: wrap;
        }
        .eg-canvas-wrap {
            flex: 1; overflow: hidden;
            padding: 0 12px 10px 12px; position: relative;
        }
        #egCanvas {
            cursor: grab; border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08); display: block;
            touch-action: none;
        }
        #egCanvas:active { cursor: grabbing; }
        #egTooltip {
            display: none; position: fixed; z-index: 100;
            background: #fff; border: 1px solid #bbb; border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 10px 14px; pointer-events: none;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 13px; color: #333; max-width: 500px;
        }
        #egTooltip.pinned {
            pointer-events: auto; cursor: auto;
            border-color: #3498db;
            box-shadow: 0 4px 20px rgba(52,152,219,0.25);
        }
        #egTooltip .tt-hint {
            font-size: 10px; color: #aaa; margin-top: 6px; font-style: italic;
        }
        #egTooltip.pinned .tt-hint { display: none; }
        #egTooltip .tt-var {
            margin: 4px 0; display: flex; align-items: baseline; gap: 6px;
        }
        #egTooltip .tt-dot {
            width: 8px; height: 8px; border-radius: 50%;
            display: inline-block; flex-shrink: 0;
        }
        #egTooltip .tt-expr {
            font-family: 'Segoe UI', system-ui, sans-serif;
            word-break: break-all; user-select: text;
        }

        /* -- scattering graph tab -- */
        #tabSG { flex-direction: column; }
        .sg-toolbar {
            display: flex; align-items: center; gap: 18px;
            padding: 8px 20px; flex-shrink: 0; flex-wrap: wrap;
        }
        .sg-canvas-wrap {
            flex: 1; overflow: hidden;
            padding: 0 12px 10px 12px; position: relative;
        }
        #sgCanvas {
            cursor: grab; border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08); display: block;
            touch-action: none;
        }
        #sgCanvas:active { cursor: grabbing; }
        #sgTooltip {
            display: none; position: fixed; z-index: 100;
            background: #fff; border: 1px solid #bbb; border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 10px 14px; pointer-events: none;
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 13px; color: #333; max-width: 500px;
        }
        #sgTooltip.pinned {
            pointer-events: auto; cursor: auto;
            border-color: #3498db;
            box-shadow: 0 4px 20px rgba(52,152,219,0.25);
        }
        #sgTooltip .tt-hint {
            font-size: 10px; color: #aaa; margin-top: 6px; font-style: italic;
        }
        #sgTooltip.pinned .tt-hint { display: none; }
        #sgTooltip .tt-var {
            margin: 4px 0; display: flex; align-items: baseline; gap: 6px;
        }
        #sgTooltip .tt-dot {
            width: 8px; height: 8px; border-radius: 50%;
            display: inline-block; flex-shrink: 0;
        }
        #sgTooltip .tt-expr {
            font-family: 'Segoe UI', system-ui, sans-serif;
            word-break: break-all; user-select: text;
        }

        /* -- about tab -- */
        #tabAbout {
            flex-direction: column;
            overflow-y: auto;
            padding: 30px 40px 60px 40px;
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
        }
        #tabAbout h2 {
            font-size: 18px; color: #2c3e50;
            margin: 24px 0 10px 0; border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }
        #tabAbout h2:first-child { margin-top: 0; }
        #tabAbout p, #tabAbout li {
            font-size: 14px; line-height: 1.7; color: #444;
        }
        #tabAbout p { margin: 8px 0; }
        #tabAbout ul, #tabAbout ol { margin: 8px 0 8px 24px; }
        #tabAbout li { margin: 4px 0; }
        #tabAbout code {
            font-family: 'Courier New', monospace;
            font-size: 13px; background: #f5f5f5;
            padding: 1px 5px; border-radius: 3px; color: #c0392b;
        }
        #tabAbout .formula {
            display: block; text-align: center;
            margin: 12px 0; font-size: 15px; color: #2c3e50;
            font-style: italic;
        }
        #tabAbout .section-note {
            font-size: 12px; color: #999; font-style: italic;
        }

        /* ---- mobile responsive ---- */
        @media (max-width: 600px) {
            .header {
                flex-wrap: wrap;
                gap: 8px;
                padding: 8px 12px;
            }
            .header h1 { font-size: 16px; }
            .header .sep { display: none; }
            .header button { padding: 5px 12px; font-size: 12px; }
            .quiver-picker label { padding: 4px 10px; font-size: 12px; }
            .quiver-controls { gap: 6px; }
            .vector-extras { gap: 2px; font-size: 12px; flex-wrap: wrap; }
            .vec-input { width: 30px; font-size: 11px; padding: 2px 3px; }
            .vec-label { margin-left: 4px; }
            .random-extras { gap: 4px; }
            .random-extras select { font-size: 12px; padding: 4px 6px; }
            .random-extras label { font-size: 12px; }

            .tab-bar {
                padding: 0 8px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .tab-btn { padding: 8px 14px; font-size: 13px; white-space: nowrap; }

            .mg-toolbar, .eg-toolbar, .sg-toolbar {
                gap: 8px;
                padding: 6px 10px;
                font-size: 12px;
            }
            .mg-hint { display: none; }
            .mg-legend { display: none; }
            .depth-control { font-size: 12px; }
            .depth-control select { font-size: 12px; padding: 3px 6px; }
            .toggle-control { font-size: 11px; gap: 4px; }
            .rotate-control { font-size: 11px; }
            .rotate-control input[type="range"] { width: 50px; }
            .mg-info { font-size: 11px; }

            .mg-canvas-wrap, .eg-canvas-wrap, .sg-canvas-wrap { padding: 0 4px 4px 4px; }

            #tabQuiver { padding: 10px 8px; gap: 10px; }
            #tabAbout { padding: 16px 14px 40px 14px; }
        }
    </style>
    <script>
    window.MathJax = {
        tex: { inlineMath: [['\\(','\\)'], ['$','$']], displayMath: [['$$','$$'], ['\\[','\\]']] },
        options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
    </script>
    <script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
    <!-- header -->
    <div class="header">
        <h1>Quiver Mutation Visualizer</h1>
        <div class="sep"></div>
        <div class="quiver-controls">
            <label>Quiver:</label>
            <div class="quiver-picker" id="quiverPicker">
                <input type="radio" name="quiverType" id="qt_scatter" value="scatter" checked>
                <label for="qt_scatter">Vector triple</label>
                <input type="radio" name="quiverType" id="qt_markov" value="markov">
                <label for="qt_markov">Markov</label>
                <input type="radio" name="quiverType" id="qt_random" value="random">
                <label for="qt_random">Random</label>
            </div>
            <div class="vector-extras" id="vectorExtras">
                <label class="vec-label" style="color:#3498db">v<sub>1</sub>=</label>(<input type="number" id="v1x" value="1" class="vec-input">,<input type="number" id="v1y" value="0" class="vec-input">)
                <label class="vec-label" style="color:#e74c3c">v<sub>2</sub>=</label>(<input type="number" id="v2x" value="0" class="vec-input">,<input type="number" id="v2y" value="-1" class="vec-input">)
                <label class="vec-label" style="color:#27ae60">v<sub>3</sub>=</label>(<input type="number" id="v3x" value="-1" class="vec-input">,<input type="number" id="v3y" value="-2" class="vec-input">)
                <button id="applyVectorsBtn">Apply</button>
            </div>
            <div class="random-extras" id="randomExtras" style="display:none">
                <select id="maxArrows">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7" selected>7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                </select>
                <label>arrows</label>
                <button id="randomizeBtn">Randomize</button>
            </div>
        </div>
    </div>

    <!-- tab bar -->
    <div class="tab-bar">
        <button class="tab-btn active" data-tab="tabQuiver">Quiver</button>
        <button class="tab-btn" data-tab="tabMG">Mutation Graph</button>
        <button class="tab-btn" data-tab="tabEG">Exchange Graph</button>
        <button class="tab-btn" data-tab="tabSG">Scattering Graph</button>
        <button class="tab-btn" data-tab="tabAbout">About</button>
    </div>

    <!-- quiver tab -->
    <div id="tabQuiver" class="tab-content active">
        <canvas id="canvas"></canvas>
        <div class="matrix-display" id="matrixDisplay"></div>
    </div>

    <!-- mutation graph tab -->
    <div id="tabMG" class="tab-content">
        <div class="mg-toolbar">
            <div class="depth-control">
                <label for="depthSelect">Depth:</label>
                <select id="depthSelect">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <div class="toggle-control">
                <label class="toggle-switch">
                    <input type="checkbox" id="mgPermToggle">
                    <span class="slider"></span>
                </label>
                <label for="mgPermToggle">Up to permutation</label>
            </div>
            <div class="mg-info" id="mgInfo"></div>
            <div class="rotate-control">
                <label>Rotate:</label>
                <input type="range" id="mgRotate" min="0" max="360" value="0">
                <span class="angle-label" id="mgAngleLabel">0&deg;</span>
            </div>
            <span class="mg-hint">scroll to zoom &middot; drag to pan</span>
            <div class="mg-legend">
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#3498db"></span>&mu;&#x2081;</div>
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#e74c3c"></span>&mu;&#x2082;</div>
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#27ae60"></span>&mu;&#x2083;</div>
                <div class="mg-legend-item"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;border:2.5px solid #f39c12"></span>initial</div>
            </div>
        </div>
        <div class="mg-canvas-wrap" id="mgWrap">
            <canvas id="mgCanvas"></canvas>
            <div class="export-container" id="mgExportContainer">
                <button class="export-btn" id="mgExportBtn">Export</button>
                <div class="export-popover" id="mgExportPopover" style="display:none">
                    <div class="ep-row">
                        <div class="ep-label">Format</div>
                        <div class="ep-options">
                            <label><input type="radio" name="mgFmt" value="pdf" checked><span>PDF</span></label>
                            <label><input type="radio" name="mgFmt" value="png"><span>PNG</span></label>
                        </div>
                    </div>
                    <div class="ep-row">
                        <div class="ep-label">Resolution</div>
                        <div class="ep-options">
                            <label><input type="radio" name="mgRes" value="2"><span>2&times;</span></label>
                            <label><input type="radio" name="mgRes" value="4" checked><span>4&times;</span></label>
                            <label><input type="radio" name="mgRes" value="8"><span>8&times;</span></label>
                        </div>
                    </div>
                    <div class="ep-row">
                        <button class="ep-go" id="mgExportGo">Export</button>
                    </div>
                </div>
            </div>
            <div class="loading-overlay" id="mgLoading" style="display:none">
                <div class="loading-text" id="mgLoadingText">Building graph...</div>
                <div class="loading-bar-track"><div class="loading-bar-fill" id="mgLoadingBar"></div></div>
            </div>
        </div>
    </div>

    <!-- exchange graph tab -->
    <div id="tabEG" class="tab-content">
        <div class="eg-toolbar">
            <div class="depth-control">
                <label for="egDepthSelect">Depth:</label>
                <select id="egDepthSelect">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <div class="toggle-control">
                <label class="toggle-switch">
                    <input type="checkbox" id="egPermToggle">
                    <span class="slider"></span>
                </label>
                <label for="egPermToggle">Up to permutation</label>
            </div>
            <div class="toggle-control">
                <label class="toggle-switch">
                    <input type="checkbox" id="egSpecToggle">
                    <span class="slider"></span>
                </label>
                <label for="egSpecToggle">Specialize x=1</label>
            </div>
            <div class="mg-info" id="egInfo"></div>
            <div class="rotate-control">
                <label>Rotate:</label>
                <input type="range" id="egRotate" min="0" max="360" value="0">
                <span class="angle-label" id="egAngleLabel">0&deg;</span>
            </div>
            <span class="mg-hint">scroll to zoom &middot; drag to pan</span>
            <div class="mg-legend">
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#3498db"></span>&mu;&#x2081;</div>
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#e74c3c"></span>&mu;&#x2082;</div>
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#27ae60"></span>&mu;&#x2083;</div>
                <div class="mg-legend-item"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;border:2.5px solid #f39c12"></span>initial</div>
            </div>
        </div>
        <div class="eg-canvas-wrap" id="egWrap">
            <canvas id="egCanvas"></canvas>
            <div class="export-container" id="egExportContainer">
                <button class="export-btn" id="egExportBtn">Export</button>
                <div class="export-popover" id="egExportPopover" style="display:none">
                    <div class="ep-row">
                        <div class="ep-label">Format</div>
                        <div class="ep-options">
                            <label><input type="radio" name="egFmt" value="pdf" checked><span>PDF</span></label>
                            <label><input type="radio" name="egFmt" value="png"><span>PNG</span></label>
                        </div>
                    </div>
                    <div class="ep-row">
                        <div class="ep-label">Resolution</div>
                        <div class="ep-options">
                            <label><input type="radio" name="egRes" value="2"><span>2&times;</span></label>
                            <label><input type="radio" name="egRes" value="4" checked><span>4&times;</span></label>
                            <label><input type="radio" name="egRes" value="8"><span>8&times;</span></label>
                        </div>
                    </div>
                    <div class="ep-row">
                        <button class="ep-go" id="egExportGo">Export</button>
                    </div>
                </div>
            </div>
            <div class="loading-overlay" id="egLoading" style="display:none">
                <div class="loading-text" id="egLoadingText">Building graph...</div>
                <div class="loading-bar-track"><div class="loading-bar-fill" id="egLoadingBar"></div></div>
            </div>
        </div>
        <div id="egTooltip"></div>
    </div>

    <!-- scattering graph tab -->
    <div id="tabSG" class="tab-content">
        <div class="sg-toolbar">
            <div class="depth-control">
                <label for="sgDepthSelect">Depth:</label>
                <select id="sgDepthSelect">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                </select>
            </div>
            <div class="toggle-control">
                <label class="toggle-switch">
                    <input type="checkbox" id="sgPermToggle">
                    <span class="slider"></span>
                </label>
                <label for="sgPermToggle">Up to permutation</label>
            </div>
            <div class="mg-info" id="sgInfo"></div>
            <div class="rotate-control">
                <label>Rotate:</label>
                <input type="range" id="sgRotate" min="0" max="360" value="0">
                <span class="angle-label" id="sgAngleLabel">0&deg;</span>
            </div>
            <span class="mg-hint">scroll to zoom &middot; drag to pan</span>
            <div class="mg-legend">
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#3498db"></span>&mu;&#x2081;</div>
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#e74c3c"></span>&mu;&#x2082;</div>
                <div class="mg-legend-item"><span class="mg-legend-dot" style="background:#27ae60"></span>&mu;&#x2083;</div>
                <div class="mg-legend-item"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;border:2.5px solid #f39c12"></span>initial</div>
            </div>
        </div>
        <div class="sg-canvas-wrap" id="sgWrap">
            <canvas id="sgCanvas"></canvas>
            <div class="export-container" id="sgExportContainer">
                <button class="export-btn" id="sgExportBtn">Export</button>
                <div class="export-popover" id="sgExportPopover" style="display:none">
                    <div class="ep-row">
                        <div class="ep-label">Format</div>
                        <div class="ep-options">
                            <label><input type="radio" name="sgFmt" value="pdf" checked><span>PDF</span></label>
                            <label><input type="radio" name="sgFmt" value="png"><span>PNG</span></label>
                        </div>
                    </div>
                    <div class="ep-row">
                        <div class="ep-label">Resolution</div>
                        <div class="ep-options">
                            <label><input type="radio" name="sgRes" value="2"><span>2&times;</span></label>
                            <label><input type="radio" name="sgRes" value="4" checked><span>4&times;</span></label>
                            <label><input type="radio" name="sgRes" value="8"><span>8&times;</span></label>
                        </div>
                    </div>
                    <div class="ep-row">
                        <button class="ep-go" id="sgExportGo">Export</button>
                    </div>
                </div>
            </div>
            <div class="loading-overlay" id="sgLoading" style="display:none">
                <div class="loading-text" id="sgLoadingText">Building graph...</div>
                <div class="loading-bar-track"><div class="loading-bar-fill" id="sgLoadingBar"></div></div>
            </div>
        </div>
        <div id="sgTooltip"></div>
    </div>

    <!-- about tab -->
    <div id="tabAbout" class="tab-content">
        <h2>AI Assistance</h2>
        <p>
            This app was created by Kyler Siegel with heavy AI assistance. There may be errors.
        </p>

        <h2>Overview</h2>
        <p>
            This is an interactive visualizer for <b>quiver mutations</b> and <b>cluster algebras</b>,
            two closely related structures introduced by Fomin and Zelevinsky in the early 2000s.
            Cluster algebras arise in diverse areas of mathematics, including representation theory,
            Teichm&uuml;ller theory, tropical geometry, and the study of scattering diagrams.
        </p>
        <p>
            The app runs entirely in the browser with no server or external dependencies&mdash;everything
            is implemented from scratch in a single HTML file using JavaScript and the Canvas API.
        </p>

        <h2>Quivers</h2>
        <p>
            A <b>quiver</b> is a directed graph, possibly with multiple edges between vertices but
            no loops (edges from a vertex to itself) and no 2-cycles (a pair of edges going in
            opposite directions between two vertices). In this visualizer we work with quivers on
            3 vertices, labeled 1, 2, 3.
        </p>
        <p>
            A quiver is equivalently described by its <b>exchange matrix</b> $B$, a
            skew-symmetric integer matrix where $B_{ij}$ records the
            number of arrows from $i$ to $j$ (positive) or from $j$ to $i$
            (negative). In rank 3, $B$ is determined by its three upper-triangular
            entries $B_{12}$, $B_{13}$, $B_{23}$.
        </p>

        <h2>Quiver mutation</h2>
        <p>
            <b>Mutation</b> at vertex $k$ transforms the exchange matrix $B$ into a
            new matrix $B'$ by the Fomin&ndash;Zelevinsky rule:
        </p>
        <div class="formula">$$B'_{ij} = \begin{cases} -B_{ij} & \text{if } i = k \text{ or } j = k, \\ B_{ij} + \dfrac{|B_{ik}|\,B_{kj} + B_{ik}\,|B_{kj}|}{2} & \text{otherwise.} \end{cases}$$</div>
        <p>
            Mutation is an <b>involution</b>: mutating twice at the same vertex returns the original quiver.
            Note also that mutation preserves skew-symmetry.
        </p>

        <h2>Mutation graph</h2>
        <p>
            The <b>mutation graph</b> shows all quivers reachable from the initial quiver by iterated
            mutations, up to a chosen depth. Vertices of this graph are quivers (identified by their
            exchange matrix), and edges correspond to single mutations, colored by which vertex was
            mutated:
            <span style="color:#3498db">$\mu_1$</span>,
            <span style="color:#e74c3c">$\mu_2$</span>,
            <span style="color:#27ae60">$\mu_3$</span>.
            Each node displays a miniature picture of the corresponding quiver.
        </p>
        <p>
            Two quivers occupy the same node if and only if their exchange matrices are identical.
            Dashed lines at the boundary indicate mutations that would lead to quivers not yet explored
            at the current depth.
        </p>

        <h2>Exchange graph &amp; cluster variables</h2>
        <p>
            A <b>cluster</b> is a triple of <b>cluster variables</b> $(x_1, x_2, x_3)$
            together with an exchange matrix.
            The initial cluster simply has formal variables $x_1, x_2, x_3$.
        </p>
        <p>
            When we mutate at vertex $k$, the exchange matrix transforms as above, and the
            cluster variable $x_k$ is replaced by a new variable $x'_k$ defined by the
            <b>exchange relation</b>:
        </p>
        <div class="formula">$$x_k \cdot x'_k = \prod_{B_{ik} > 0} x_i^{B_{ik}} + \prod_{B_{ik} < 0} x_i^{-B_{ik}}$$</div>
        <p>
            The other two variables remain unchanged. The <b>exchange graph</b> records all
            (quiver, cluster) pairs reachable by iterated mutations. Unlike the mutation graph,
            two nodes are identified only when <em>both</em> the exchange matrix and the cluster
            variables agree. This means the exchange graph may have more nodes than the mutation graph.
        </p>
        <p>
            A foundational result in the theory of cluster algebras is the <b>Laurent phenomenon</b>
            (Fomin&ndash;Zelevinsky, 2002): every cluster variable can be expressed as a
            Laurent polynomial in the initial variables $x_1, x_2, x_3$&mdash;that is, a polynomial
            with integer coefficients divided by a monomial. This is nontrivial because the exchange
            relation involves division, and it is not obvious a priori that repeated application
            always produces Laurent polynomials.
        </p>

        <h2>Preset quivers</h2>
        <ul>
            <li>
                <b>Vector triple</b> &mdash; A quiver defined by three user-specified vectors
                $\mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3 \in \mathbb{Z}^2$.
                The exchange matrix entry $B_{ij}$ is the determinant
                $\det(\mathbf{v}_i, \mathbf{v}_j)$.
                The default vectors $(1, 0), (0, -1), (-1, -2)$ correspond
                to the Hirzebruch surface $F_1$.
            </li>
            <li>
                <b>Markov</b> &mdash; A 3-cycle with 2 arrows on each edge, related to the Markov equation
                $x^2 + y^2 + z^2 = 3xyz$.
            </li>
            <li>
                <b>Random</b> &mdash; A randomly generated quiver (no loops or 2-cycles) with a configurable
                specified number of arrows.
            </li>
        </ul>

        <h2>Implementation details</h2>
        <p>
            The entire application is self-contained in a single HTML file with inline CSS and JavaScript.
            No external libraries are used for the core functionality (jsPDF is loaded on demand from a CDN
            only when PDF export is requested).
        </p>
        <p><b>Laurent polynomial arithmetic.</b>
            Cluster variables are represented as Laurent polynomials in $x_1, x_2, x_3$.
            Internally, each Laurent polynomial is stored
            as a JavaScript <code>Map</code> from exponent triples (e.g. <code>"2,-1,0"</code> for
            $x_1^2 x_2^{-1}$) to integer coefficients.
            No external computer algebra system is used&mdash;addition, multiplication, exponentiation,
            and exact polynomial division are all implemented from scratch.
        </p>
        <p>
            The division step deserves special mention: when computing the exchange relation,
            we must divide a polynomial by a (potentially complex) Laurent polynomial. This is done via
            multivariate polynomial long division with lexicographic monomial ordering. The Laurent
            phenomenon guarantees that this division is always exact (zero remainder), so the algorithm
            is correct for our use case. Coefficients are rounded to integers after each operation to
            avoid floating-point drift.
        </p>
        <p><b>Graph layout.</b>
            Both the mutation graph and exchange graph use a custom <b>force-directed layout</b> algorithm.
            Nodes are initialized on concentric rings (by BFS depth from the initial quiver), then
            iteratively adjusted: a repulsive Coulomb-like force pushes all node pairs apart, an
            attractive spring force pulls connected nodes together, and a mild gravitational pull toward
            the center prevents drift. The number of iterations adapts to graph size.
        </p>
        <p><b>Rendering.</b>
            All graphics are drawn on HTML5 Canvas elements, scaled by <code>devicePixelRatio</code> for
            crisp rendering on high-DPI displays. Zoom uses <code>Math.exp(-deltaY * 0.002)</code> for
            smooth, proportional scrolling on trackpads. Mutation graph nodes are circles containing mini
            quiver drawings; exchange graph nodes are rounded rectangles showing both the quiver and the
            three cluster variable expressions.
        </p>
        <p><b>Graph construction.</b>
            Both graphs are built by breadth-first search from the initial (quiver, cluster) pair.
            At each depth level, all three possible mutations are applied to each frontier node.
            For the mutation graph, nodes are identified by exchange matrix alone; for the exchange graph,
            nodes are identified by the pair (exchange matrix, cluster variables). A cap of 500 nodes
            prevents the browser from hanging on deeply explored graphs. Dashed &ldquo;stub&rdquo; edges
            at the frontier indicate mutations that would produce new nodes beyond the current depth.
        </p>

        <p class="section-note">Last updated: February 19, 2026.</p>
    </div>

    <script>
    // ===========================================================
    //  CONSTANTS
    // ===========================================================
    const VERTEX_COLORS = ['#3498db', '#e74c3c', '#27ae60'];
    const ARROW_COLOR = '#4a4a4a';
    let VERTEX_RADIUS = 30;
    const MG_NODE_R = 42;
    const EG_NODE_W = 160, EG_NODE_H = 100, EG_NODE_R = 95;
    const MAX_GRAPH_NODES = 500;

    // ===========================================================
    //  STATE
    // ===========================================================
    let quiver = [[0,0,0],[0,0,0],[0,0,0]];
    let currentGraph = null;
    let currentLayout = null;
    let mgScale = 1, mgPanX = 0, mgPanY = 0;
    let mgDragging = false, mgDragX = 0, mgDragY = 0, mgDragPanX = 0, mgDragPanY = 0;
    let mgRotation = 0; // radians
    let mgNeedsRebuild = true;  // deferred build when switching to tab

    let currentEGGraph = null, currentEGLayout = null;
    let egScale = 1, egPanX = 0, egPanY = 0;
    let egDragging = false, egDragX = 0, egDragY = 0, egDragPanX = 0, egDragPanY = 0;
    let egRotation = 0; // radians
    let egSpecialize = false;
    let egNeedsRebuild = true;

    let currentSGGraph = null, currentSGLayout = null;
    let sgScale = 1, sgPanX = 0, sgPanY = 0;
    let sgDragging = false, sgDragX = 0, sgDragY = 0, sgDragPanX = 0, sgDragPanY = 0;
    let sgRotation = 0;
    let sgNeedsRebuild = true;
    const SG_NODE_W = 120, SG_NODE_H = 100, SG_NODE_R = 78;

    // ===========================================================
    //  CANVASES
    // ===========================================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const mgCanvas = document.getElementById('mgCanvas');
    const mgCtx = mgCanvas.getContext('2d');
    const egCanvas = document.getElementById('egCanvas');
    const egCtx = egCanvas.getContext('2d');
    const sgCanvas = document.getElementById('sgCanvas');
    const sgCtx = sgCanvas.getContext('2d');

    // Vertex positions for main quiver display (recomputed on resize)
    let qCenterX, qCenterY, triR;
    const qVerts = [{x:0,y:0},{x:0,y:0},{x:0,y:0}];
    function sizeQuiverCanvas() {
        const wrap = document.getElementById('tabQuiver');
        const dpr = window.devicePixelRatio || 1;
        const maxW = wrap.clientWidth - 20;
        const maxH = wrap.clientHeight - 100;
        const w = Math.min(600, maxW);
        const h = Math.min(480, maxH);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        canvas.width = Math.round(w * dpr);
        canvas.height = Math.round(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        qCenterX = w / 2;
        qCenterY = h / 2 + 10;
        triR = Math.min(w, h) * 0.32;
        VERTEX_RADIUS = Math.max(16, Math.round(triR * 0.19));
        for (let i = 0; i < 3; i++) {
            const a = -Math.PI / 2 + i * 2 * Math.PI / 3;
            qVerts[i] = { x: qCenterX + triR * Math.cos(a), y: qCenterY + triR * Math.sin(a) };
        }
    }

    // ===========================================================
    //  TABS
    // ===========================================================
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById(btn.dataset.tab).classList.add('active');
            if (btn.dataset.tab === 'tabQuiver') {
                sizeQuiverCanvas(); drawQuiver();
            } else if (btn.dataset.tab === 'tabMG') {
                sizeMGCanvas();
                if (mgNeedsRebuild) { updateMutationGraph(); mgNeedsRebuild = false; }
                else drawMutationGraph();
            } else if (btn.dataset.tab === 'tabEG') {
                sizeEGCanvas();
                if (egNeedsRebuild) { updateExchangeGraph(); egNeedsRebuild = false; }
                else drawExchangeGraph();
            } else if (btn.dataset.tab === 'tabSG') {
                sizeSGCanvas();
                if (sgNeedsRebuild) { updateScatteringGraph(); sgNeedsRebuild = false; }
                else drawScatteringGraph();
            } else if (btn.dataset.tab === 'tabAbout') {
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetPromise([document.getElementById('tabAbout')]);
                }
            }
        });
    });

    // ===========================================================
    //  DYNAMIC CANVAS SIZING
    // ===========================================================
    function sizeMGCanvas() {
        const wrap = document.getElementById('mgWrap');
        const dpr = window.devicePixelRatio || 1;
        const w = wrap.clientWidth;
        const h = wrap.clientHeight;
        mgCanvas.style.width = w + 'px';
        mgCanvas.style.height = h + 'px';
        mgCanvas.width = Math.round(w * dpr);
        mgCanvas.height = Math.round(h * dpr);
        mgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    function sizeEGCanvas() {
        const wrap = document.getElementById('egWrap');
        const dpr = window.devicePixelRatio || 1;
        const w = wrap.clientWidth, h = wrap.clientHeight;
        egCanvas.style.width = w + 'px'; egCanvas.style.height = h + 'px';
        egCanvas.width = Math.round(w * dpr); egCanvas.height = Math.round(h * dpr);
        egCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    function sizeSGCanvas() {
        const wrap = document.getElementById('sgWrap');
        const dpr = window.devicePixelRatio || 1;
        const w = wrap.clientWidth, h = wrap.clientHeight;
        sgCanvas.style.width = w + 'px'; sgCanvas.style.height = h + 'px';
        sgCanvas.width = Math.round(w * dpr); sgCanvas.height = Math.round(h * dpr);
        sgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', () => {
        if (document.getElementById('tabQuiver').classList.contains('active')) {
            sizeQuiverCanvas(); drawQuiver();
        }
        if (document.getElementById('tabMG').classList.contains('active')) {
            sizeMGCanvas(); drawMutationGraph();
        }
        if (document.getElementById('tabEG').classList.contains('active')) {
            sizeEGCanvas(); drawExchangeGraph();
        }
        if (document.getElementById('tabSG').classList.contains('active')) {
            sizeSGCanvas(); drawScatteringGraph();
        }
    });

    // ===========================================================
    //  PRESET QUIVERS
    // ===========================================================
    // Markov quiver: 3-cycle, 2 arrows on each edge
    const PRESET_MARKOV = [[0,2,0],[0,0,2],[2,0,0]];

    // Current custom vectors for vector triple mode
    let customVectors = [[1, 0], [0, -1], [-1, -2]];

    function raysToQuiver(rays) {
        // Build upper-triangular quiver from det(vi, vj)
        const Q = [[0,0,0],[0,0,0],[0,0,0]];
        for (let i = 0; i < 3; i++)
            for (let j = i + 1; j < 3; j++) {
                const d = rays[i][0] * rays[j][1] - rays[i][1] * rays[j][0];
                if (d > 0) Q[i][j] = d;
                else if (d < 0) Q[j][i] = -d;
            }
        return Q;
    }

    function readVectorInputs() {
        return [
            [parseInt(document.getElementById('v1x').value) || 0, parseInt(document.getElementById('v1y').value) || 0],
            [parseInt(document.getElementById('v2x').value) || 0, parseInt(document.getElementById('v2y').value) || 0],
            [parseInt(document.getElementById('v3x').value) || 0, parseInt(document.getElementById('v3y').value) || 0]
        ];
    }

    function applyVectorTriple() {
        customVectors = readVectorInputs();
        setQuiver(raysToQuiver(customVectors));
    }

    // ===========================================================
    //  QUIVER SELECTION
    // ===========================================================
    function setQuiver(Q) {
        quiver = Q.map(r => [...r]);
        drawQuiver();
        displayMatrix();
        if (document.getElementById('tabMG').classList.contains('active')) {
            updateMutationGraph(); mgNeedsRebuild = false;
        } else { mgNeedsRebuild = true; }
        if (document.getElementById('tabEG').classList.contains('active')) {
            updateExchangeGraph(); egNeedsRebuild = false;
        } else { egNeedsRebuild = true; }
        if (document.getElementById('tabSG').classList.contains('active')) {
            updateScatteringGraph(); sgNeedsRebuild = false;
        } else { sgNeedsRebuild = true; }
    }

    function generateRandomQuiver() {
        const maxA = parseInt(document.getElementById('maxArrows').value);
        const Q = [[0,0,0],[0,0,0],[0,0,0]];
        const total = maxA;
        const pairs = [[0,1],[0,2],[1,2]];
        const dist = [0,0,0];
        for (let e = 0; e < total; e++) dist[Math.floor(Math.random() * 3)]++;
        for (let p = 0; p < 3; p++) {
            if (dist[p] > 0) {
                const [i, j] = pairs[p];
                if (Math.random() < 0.5) Q[i][j] = dist[p];
                else Q[j][i] = dist[p];
            }
        }
        setQuiver(Q);
    }

    function getQuiverType() {
        return document.querySelector('input[name="quiverType"]:checked').value;
    }
    function applyQuiverSelection() {
        const type = getQuiverType();
        document.getElementById('vectorExtras').style.display = type === 'scatter' ? 'flex' : 'none';
        document.getElementById('randomExtras').style.display = type === 'random' ? 'flex' : 'none';
        if (type === 'scatter') applyVectorTriple();
        else if (type === 'markov') setQuiver(PRESET_MARKOV);
        else generateRandomQuiver();
    }

    // ===========================================================
    //  MAIN QUIVER DRAWING
    // ===========================================================
    function drawQuiver() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                if (i !== j && quiver[i][j] > 0) drawMainEdges(i, j, quiver[i][j]);
        for (let i = 0; i < 3; i++) drawMainVertex(i);
    }

    function drawMainEdges(from, to, count) {
        drawMainArrow(from, to, count);
    }

    function drawMainArrow(fi, ti, count) {
        const f = qVerts[fi], t = qVerts[ti];
        const dx = t.x-f.x, dy = t.y-f.y, len = Math.sqrt(dx*dx+dy*dy);
        const ux = dx/len, uy = dy/len, px = -uy, py = ux;
        const cpX = (f.x+t.x)/2, cpY = (f.y+t.y)/2;
        const sd = norm(cpX-f.x, cpY-f.y), ed = norm(t.x-cpX, t.y-cpY);
        const gap = VERTEX_RADIUS + 5;
        const sx = f.x+(cpX-f.x)/sd*gap, sy = f.y+(cpY-f.y)/sd*gap;
        const ex = t.x-(t.x-cpX)/ed*gap, ey = t.y-(t.y-cpY)/ed*gap;
        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
        ctx.strokeStyle = ARROW_COLOR; ctx.lineWidth = 2; ctx.stroke();
        arrowhead(ctx, ex, ey, ux, uy, Math.max(8, VERTEX_RADIUS * 0.43), ARROW_COLOR);
        if (count > 1) {
            const labelOff = Math.max(10, VERTEX_RADIUS * 0.53);
            const mx = (sx+ex)/2 + px*labelOff, my = (sy+ey)/2 + py*labelOff;
            ctx.font = 'bold ' + Math.max(11, Math.round(VERTEX_RADIUS * 0.53)) + 'px "Segoe UI",sans-serif';
            ctx.fillStyle = ARROW_COLOR;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(''+count, mx, my);
        }
    }

    function drawMainVertex(i) {
        const v = qVerts[i];
        ctx.beginPath(); ctx.arc(v.x,v.y+3,VERTEX_RADIUS,0,Math.PI*2);
        ctx.fillStyle='rgba(0,0,0,0.10)'; ctx.fill();
        ctx.beginPath(); ctx.arc(v.x,v.y,VERTEX_RADIUS,0,Math.PI*2);
        ctx.fillStyle=VERTEX_COLORS[i]; ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.lineWidth=2; ctx.stroke();
        ctx.fillStyle='#fff'; ctx.font='bold ' + Math.max(14, Math.round(VERTEX_RADIUS * 0.73)) + 'px "Segoe UI",sans-serif';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(''+(i+1), v.x, v.y+1);
    }

    function displayMatrix() {
        const B = quiverToMatrix(quiver);
        let html = '<div class="label">Exchange matrix B</div>';
        for (let i = 0; i < 3; i++) {
            const L = i===0?'':i===1?'':'', R = i===0?'':i===1?'':'';
            const vals = B[i].map(v => `<span>${v>=0?'\u2007'+v:''+v}</span>`).join('');
            html += `<div class="matrix-row">${L}${vals}\u2007${R}</div>`;
        }
        document.getElementById('matrixDisplay').innerHTML = html;
    }

    // ===========================================================
    //  HELPERS
    // ===========================================================
    function norm(x,y) { return Math.sqrt(x*x+y*y); }

    function arrowhead(c, x, y, tx, ty, size, color) {
        const a = Math.PI/6, ca = Math.cos(a), sa = Math.sin(a);
        c.beginPath(); c.moveTo(x, y);
        c.lineTo(x - size*(tx*ca - ty*sa), y - size*(tx*sa + ty*ca));
        c.lineTo(x - size*(tx*ca + ty*sa), y - size*(ty*ca - tx*sa));
        c.closePath(); c.fillStyle = color; c.fill();
    }

    // ===========================================================
    //  MUTATION ALGEBRA
    // ===========================================================
    function quiverToMatrix(Q) {
        const B = [[0,0,0],[0,0,0],[0,0,0]];
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                B[i][j] = Q[i][j] - Q[j][i];
        return B;
    }

    function matrixToQuiver(B) {
        const Q = [[0,0,0],[0,0,0],[0,0,0]];
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                Q[i][j] = Math.max(0, B[i][j]);
        return Q;
    }

    function mutateMatrix(B, k) {
        const B2 = B.map(r => [...r]);
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (i === k || j === k) {
                    B2[i][j] = -B[i][j];
                } else {
                    B2[i][j] = B[i][j] + (Math.abs(B[i][k]) * B[k][j] + B[i][k] * Math.abs(B[k][j])) / 2;
                }
            }
        }
        return B2;
    }

    function matrixKey(B) {
        return B[0][1] + ',' + B[0][2] + ',' + B[1][2];
    }

    // ===========================================================
    //  PERMUTATION EQUIVALENCE
    // ===========================================================
    const PERMS_3 = [[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]];

    function permuteMatrix(B, p) {
        const P = [[0,0,0],[0,0,0],[0,0,0]];
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                P[i][j] = B[p[i]][p[j]];
        return P;
    }

    function canonicalMatrixKey(B) {
        let best = matrixKey(B);
        for (let pi = 1; pi < PERMS_3.length; pi++) {
            const key = matrixKey(permuteMatrix(B, PERMS_3[pi]));
            if (key < best) best = key;
        }
        return best;
    }

    function canonicalMatrix(B) {
        let bestKey = matrixKey(B), bestB = B;
        for (let pi = 1; pi < PERMS_3.length; pi++) {
            const P = permuteMatrix(B, PERMS_3[pi]);
            const key = matrixKey(P);
            if (key < bestKey) { bestKey = key; bestB = P; }
        }
        return bestB;
    }

    // Permute variable indices inside a Laurent polynomial:
    // x_i -> x_{p[i]}, so exponent e becomes newExp where newExp[p[i]] = e[i].
    function permuteLPVars(lp, p) {
        const result = new Map();
        for (const [key, coeff] of lp) {
            const e = key.split(',').map(Number);
            const ne = [0, 0, 0];
            for (let i = 0; i < 3; i++) ne[p[i]] = e[i];
            const nk = ne.join(',');
            result.set(nk, (result.get(nk) || 0) + coeff);
        }
        return result;
    }

    // Permute a cluster: reorder slots AND permute vars within each LP.
    function permuteCluster(cluster, p) {
        return [
            permuteLPVars(cluster[p[0]], p),
            permuteLPVars(cluster[p[1]], p),
            permuteLPVars(cluster[p[2]], p)
        ];
    }

    function egNodeKey(B, cluster) {
        return matrixKey(B) + '###' + clusterKey(cluster);
    }

    function canonicalEGKey(B, cluster) {
        let best = egNodeKey(B, cluster);
        for (let pi = 1; pi < PERMS_3.length; pi++) {
            const p = PERMS_3[pi];
            const key = egNodeKey(permuteMatrix(B, p), permuteCluster(cluster, p));
            if (key < best) best = key;
        }
        return best;
    }

    function canonicalEGData(B, cluster) {
        let bestKey = egNodeKey(B, cluster), bestB = B, bestC = cluster;
        for (let pi = 1; pi < PERMS_3.length; pi++) {
            const p = PERMS_3[pi];
            const pB = permuteMatrix(B, p);
            const pC = permuteCluster(cluster, p);
            const key = egNodeKey(pB, pC);
            if (key < bestKey) { bestKey = key; bestB = pB; bestC = pC; }
        }
        return { matrix: bestB, cluster: bestC };
    }

    // Specialize-at-1 key: uses integer values instead of full LP strings
    function egNodeKeySpec(B, cluster) {
        return matrixKey(B) + '###' + clusterIntKey(cluster);
    }

    function canonicalEGKeySpec(B, cluster) {
        let best = egNodeKeySpec(B, cluster);
        for (let pi = 1; pi < PERMS_3.length; pi++) {
            const p = PERMS_3[pi];
            const key = egNodeKeySpec(permuteMatrix(B, p), permuteCluster(cluster, p));
            if (key < best) best = key;
        }
        return best;
    }

    function canonicalEGDataSpec(B, cluster) {
        let bestKey = egNodeKeySpec(B, cluster), bestB = B, bestC = cluster;
        for (let pi = 1; pi < PERMS_3.length; pi++) {
            const p = PERMS_3[pi];
            const pB = permuteMatrix(B, p);
            const pC = permuteCluster(cluster, p);
            const key = egNodeKeySpec(pB, pC);
            if (key < bestKey) { bestKey = key; bestB = pB; bestC = pC; }
        }
        return { matrix: bestB, cluster: bestC };
    }

    // ===========================================================
    //  LAURENT POLYNOMIAL ARITHMETIC
    // ===========================================================
    // Represented as Map: "e1,e2,e3" -> integer coefficient
    function lpOne() { const m = new Map(); m.set('0,0,0', 1); return m; }
    function lpVar(i) { const e = [0,0,0]; e[i] = 1; const m = new Map(); m.set(e.join(','), 1); return m; }
    function lpClone(p) { return new Map(p); }

    function lpAdd(a, b) {
        const r = new Map(a);
        for (const [k, v] of b) {
            const s = (r.get(k) || 0) + v;
            if (Math.abs(s) < 0.5) r.delete(k); else r.set(k, Math.round(s));
        }
        return r;
    }

    function lpMul(a, b) {
        const r = new Map();
        for (const [ka, va] of a) {
            const ea = ka.split(',').map(Number);
            for (const [kb, vb] of b) {
                const eb = kb.split(',').map(Number);
                const key = ea.map((e, i) => e + eb[i]).join(',');
                const s = (r.get(key) || 0) + va * vb;
                if (Math.abs(s) < 0.5) r.delete(key); else r.set(key, Math.round(s));
            }
        }
        return r;
    }

    function lpPow(p, n) {
        if (n === 0) return lpOne();
        let r = lpOne();
        for (let i = 0; i < n; i++) r = lpMul(r, p);
        return r;
    }

    // Exact division f/g (guaranteed by Laurent phenomenon)
    function lpDiv(f, g) {
        const q = new Map();
        const rem = new Map(f);
        // leading term of g (lex order)
        let ltgKey = null, ltgExp = null;
        for (const key of g.keys()) {
            const e = key.split(',').map(Number);
            if (!ltgExp || expGt(e, ltgExp)) { ltgKey = key; ltgExp = e; }
        }
        const ltgCoeff = g.get(ltgKey);
        let safety = 50000;
        while (rem.size > 0 && safety-- > 0) {
            let bestKey = null, bestExp = null;
            for (const key of rem.keys()) {
                const e = key.split(',').map(Number);
                if (!bestExp || expGt(e, bestExp)) { bestKey = key; bestExp = e; }
            }
            const ltrCoeff = rem.get(bestKey);
            const qExp = bestExp.map((e, i) => e - ltgExp[i]);
            const qCoeff = Math.round(ltrCoeff / ltgCoeff);
            const qKey = qExp.join(',');
            q.set(qKey, (q.get(qKey) || 0) + qCoeff);
            for (const [gk, gv] of g) {
                const ge = gk.split(',').map(Number);
                const sk = ge.map((e, i) => e + qExp[i]).join(',');
                const sv = (rem.get(sk) || 0) - qCoeff * gv;
                if (Math.abs(sv) < 0.5) rem.delete(sk); else rem.set(sk, Math.round(sv));
            }
        }
        return q;
    }

    function expGt(a, b) {
        for (let i = 0; i < 3; i++) { if (a[i] !== b[i]) return a[i] > b[i]; }
        return false;
    }

    function lpEqual(a, b) {
        if (a.size !== b.size) return false;
        for (const [k, v] of a) { if ((b.get(k) || 0) !== v) return false; }
        return true;
    }

    function lpKey(p) {
        if (p.size === 0) return '0';
        const entries = [...p.entries()].sort((a, b) => a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0);
        return entries.map(([k, v]) => v + ':' + k).join('|');
    }

    function clusterKey(cluster) { return cluster.map(lpKey).join('##'); }

    // Format Laurent polynomial for display
    const SUP = '\u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079';
    const SUB = ['\u2081', '\u2082', '\u2083'];

    function lpToString(lp) {
        if (lp.size === 0) return '0';
        let minE = [Infinity, Infinity, Infinity];
        for (const key of lp.keys()) {
            const e = key.split(',').map(Number);
            for (let i = 0; i < 3; i++) minE[i] = Math.min(minE[i], e[i]);
        }
        // only shift negative exponents to zero (for denominator)
        const shift = minE.map(v => v < 0 ? -v : 0);
        const terms = [];
        for (const [key, coeff] of lp) {
            const e = key.split(',').map(Number);
            terms.push({ coeff: Math.round(coeff), exp: e.map((v, i) => v + shift[i]) });
        }
        terms.sort((a, b) => {
            const da = a.exp[0]+a.exp[1]+a.exp[2], db = b.exp[0]+b.exp[1]+b.exp[2];
            if (da !== db) return db - da;
            for (let i = 0; i < 3; i++) if (a.exp[i] !== b.exp[i]) return b.exp[i] - a.exp[i];
            return 0;
        });

        function fmtSup(n) { return String(n).split('').map(d => SUP[parseInt(d)]).join(''); }
        function fmtMono(exp) {
            let s = '';
            for (let i = 0; i < 3; i++) {
                if (exp[i] === 0) continue;
                s += 'x' + SUB[i];
                if (exp[i] > 1) s += fmtSup(exp[i]);
            }
            return s || null;
        }

        let num = '';
        for (let i = 0; i < terms.length; i++) {
            const t = terms[i], mono = fmtMono(t.exp), c = t.coeff, first = i === 0;
            if (mono) {
                if (c === 1) num += first ? mono : '+' + mono;
                else if (c === -1) num += '-' + mono;
                else num += (first ? '' : c > 0 ? '+' : '') + c + mono;
            } else {
                num += (first ? '' : c > 0 ? '+' : '') + c;
            }
        }

        const den = fmtMono(shift);
        if (!den) return num;
        if (terms.length === 1) return num + '/' + den;
        return '(' + num + ')/' + den;
    }

    // Evaluate LP at x=x=x=1 (sum of all coefficients)
    function lpEvalAtOne(lp) {
        let sum = 0;
        for (const coeff of lp.values()) sum += coeff;
        return sum;
    }

    function clusterIntKey(cluster) {
        return cluster.map(lpEvalAtOne).join(',');
    }

    // ===========================================================
    //  EXCHANGE MUTATION (CLUSTER ALGEBRA)
    // ===========================================================
    function mutateCluster(B, cluster, k) {
        // x'_k = (prod_+ + prod_-) / x_k
        let prodPos = lpOne(), prodNeg = lpOne();
        for (let i = 0; i < 3; i++) {
            if (i === k) continue;
            if (B[i][k] > 0) prodPos = lpMul(prodPos, lpPow(cluster[i], B[i][k]));
            if (B[i][k] < 0) prodNeg = lpMul(prodNeg, lpPow(cluster[i], -B[i][k]));
        }
        const numerator = lpAdd(prodPos, prodNeg);
        const newVar = lpDiv(numerator, cluster[k]);
        return cluster.map((v, i) => i === k ? newVar : lpClone(v));
    }

    // ===========================================================
    //  EXCHANGE GRAPH CONSTRUCTION (BFS)
    // ===========================================================
    function buildExchangeGraph(initialB, maxDepth, upToPermutation, specializeAtOne) {
        const nodes = new Map();
        const edgeSet = new Set();
        const edges = [];

        let keyFn, dataFn;
        if (upToPermutation && specializeAtOne) {
            keyFn = canonicalEGKeySpec;
            dataFn = (B, cl) => canonicalEGDataSpec(B, cl);
        } else if (upToPermutation) {
            keyFn = canonicalEGKey;
            dataFn = (B, cl) => canonicalEGData(B, cl);
        } else if (specializeAtOne) {
            keyFn = egNodeKeySpec;
            dataFn = (B, cl) => ({ matrix: B, cluster: cl });
        } else {
            keyFn = egNodeKey;
            dataFn = (B, cl) => ({ matrix: B, cluster: cl });
        }

        const initialCluster = [lpVar(0), lpVar(1), lpVar(2)];
        const initData = dataFn(initialB, initialCluster);
        const ik = keyFn(initData.matrix, initData.cluster);
        nodes.set(ik, { matrix: initData.matrix, cluster: initData.cluster, depth: 0 });
        let frontier = [ik];
        let capped = false;

        function addEdge(from, to, label) {
            const ek = from + '|' + label;
            if (edgeSet.has(ek)) return;
            edgeSet.add(ek);
            edges.push({ from, to, label });
        }

        for (let d = 0; d < maxDepth; d++) {
            const next = [];
            for (const key of frontier) {
                const nd = nodes.get(key);
                for (let k = 0; k < 3; k++) {
                    const B2raw = mutateMatrix(nd.matrix, k);
                    const cl2raw = mutateCluster(nd.matrix, nd.cluster, k);
                    const dat = dataFn(B2raw, cl2raw);
                    const k2 = keyFn(dat.matrix, dat.cluster);
                    if (k2 === key) { addEdge(key, key, k); continue; }
                    if (!nodes.has(k2)) {
                        if (nodes.size >= MAX_GRAPH_NODES) { capped = true; continue; }
                        nodes.set(k2, { matrix: dat.matrix, cluster: dat.cluster, depth: d + 1 });
                        next.push(k2);
                    }
                    addEdge(key, k2, k);
                }
            }
            frontier = next;
        }
        // boundary edges from frontier nodes to known nodes
        for (const key of frontier) {
            const nd = nodes.get(key);
            for (let k = 0; k < 3; k++) {
                const B2raw = mutateMatrix(nd.matrix, k);
                const cl2raw = mutateCluster(nd.matrix, nd.cluster, k);
                const dat = dataFn(B2raw, cl2raw);
                const k2 = keyFn(dat.matrix, dat.cluster);
                if (!nodes.has(k2)) continue;
                addEdge(key, k2, k);
            }
        }
        // frontier stubs
        const stubs = [];
        for (const key of frontier) {
            const nd = nodes.get(key);
            for (let k = 0; k < 3; k++) {
                const B2raw = mutateMatrix(nd.matrix, k);
                const cl2raw = mutateCluster(nd.matrix, nd.cluster, k);
                const dat = dataFn(B2raw, cl2raw);
                const k2 = keyFn(dat.matrix, dat.cluster);
                if (nodes.has(k2)) continue;
                stubs.push({ from: key, label: k });
            }
        }
        // Merge directed edges into visual edges (same approach as mutation graph)
        const selfLoopMap = new Map();
        const pairMap = new Map();
        for (const e of edges) {
            if (e.from === e.to) {
                if (!selfLoopMap.has(e.from)) selfLoopMap.set(e.from, []);
                selfLoopMap.get(e.from).push(e.label);
                continue;
            }
            const aKey = e.from < e.to ? e.from : e.to;
            const bKey = e.from < e.to ? e.to : e.from;
            const pk = aKey + '||' + bKey;
            if (!pairMap.has(pk)) pairMap.set(pk, { a: aKey, b: bKey, labelsA: [], labelsB: [] });
            const p = pairMap.get(pk);
            if (e.from === p.a) p.labelsA.push(e.label); else p.labelsB.push(e.label);
        }
        const visualEdges = [];
        for (const p of pairMap.values()) {
            visualEdges.push({
                from: p.a, to: p.b,
                labelsA: p.labelsA.sort(),
                labelsB: p.labelsB.sort(),
            });
        }
        const selfLoops = [];
        for (const [nodeKey, labels] of selfLoopMap) {
            selfLoops.push({ from: nodeKey, labels: labels.sort() });
        }
        return { nodes, edges: visualEdges, selfLoops, stubs, initialKey: ik, capped };
    }

    // ===========================================================
    //  MUTATION GRAPH CONSTRUCTION (BFS)
    // ===========================================================
    function buildMutationGraph(initialB, maxDepth, upToPermutation) {
        const nodes = new Map();
        const edgeSet = new Set();
        const edges = [];
        const keyFn = upToPermutation ? canonicalMatrixKey : matrixKey;
        const matFn = upToPermutation ? canonicalMatrix : (B => B);

        const initB = matFn(initialB);
        const ik = keyFn(initB);
        nodes.set(ik, { matrix: initB, depth: 0 });
        let frontier = [ik];
        let capped = false;

        // Each edge is directed: (from, label) uniquely identifies it.
        // This ensures each node has exactly 3 outgoing edges (k=0,1,2).
        function addEdge(from, to, label) {
            const ek = from + '|' + label;
            if (edgeSet.has(ek)) return;
            edgeSet.add(ek);
            edges.push({ from, to, label });
        }

        for (let d = 0; d < maxDepth; d++) {
            const next = [];
            for (const key of frontier) {
                const B = nodes.get(key).matrix;
                for (let k = 0; k < 3; k++) {
                    const B2raw = mutateMatrix(B, k);
                    const B2 = matFn(B2raw);
                    const k2 = keyFn(B2);
                    if (k2 === key) { addEdge(key, key, k); continue; }
                    if (!nodes.has(k2)) {
                        if (nodes.size >= MAX_GRAPH_NODES) { capped = true; continue; }
                        nodes.set(k2, { matrix: B2, depth: d + 1 });
                        next.push(k2);
                    }
                    addEdge(key, k2, k);
                }
            }
            frontier = next;
        }
        // Add edges from frontier nodes to already-known nodes
        for (const key of frontier) {
            const B = nodes.get(key).matrix;
            for (let k = 0; k < 3; k++) {
                const B2raw = mutateMatrix(B, k);
                const B2 = matFn(B2raw);
                const k2 = keyFn(B2);
                if (!nodes.has(k2)) continue;
                addEdge(key, k2, k);
            }
        }

        // Frontier stubs: mutations leading outside the explored graph
        const stubs = [];
        for (const key of frontier) {
            const B = nodes.get(key).matrix;
            for (let k = 0; k < 3; k++) {
                const B2raw = mutateMatrix(B, k);
                const k2 = keyFn(matFn(B2raw));
                if (nodes.has(k2)) continue;
                stubs.push({ from: key, label: k });
            }
        }

        // Merge directed edges into visual edges:
        // - Self-loops grouped by node
        // - All edges between the same pair of nodes collapse into ONE
        //   visual edge carrying all labels from both directions
        const selfLoopMap = new Map(); // nodeKey  [labels]
        const pairMap = new Map();     // "A||B"  { a, b, labelsA:[], labelsB:[] }
        for (const e of edges) {
            if (e.from === e.to) {
                if (!selfLoopMap.has(e.from)) selfLoopMap.set(e.from, []);
                selfLoopMap.get(e.from).push(e.label);
                continue;
            }
            const aKey = e.from < e.to ? e.from : e.to;
            const bKey = e.from < e.to ? e.to : e.from;
            const pk = aKey + '||' + bKey;
            if (!pairMap.has(pk)) pairMap.set(pk, { a: aKey, b: bKey, labelsA: [], labelsB: [] });
            const p = pairMap.get(pk);
            if (e.from === p.a) p.labelsA.push(e.label); else p.labelsB.push(e.label);
        }

        // One visual edge per unordered pair, carrying all labels
        const visualEdges = [];
        for (const p of pairMap.values()) {
            visualEdges.push({
                from: p.a, to: p.b,
                labelsA: p.labelsA.sort(),  // mutations AB (labels from A's perspective)
                labelsB: p.labelsB.sort(),  // mutations BA (labels from B's perspective)
            });
        }

        // Self-loops: one entry per node, carrying all self-loop labels
        const selfLoops = [];
        for (const [nodeKey, labels] of selfLoopMap) {
            selfLoops.push({ from: nodeKey, labels: labels.sort() });
        }

        return { nodes, edges: visualEdges, selfLoops, stubs, initialKey: ik, capped };
    }

    // ===========================================================
    //  LOADING OVERLAY HELPERS
    // ===========================================================
    function showLoading(id, text, pct) {
        const overlay = document.getElementById(id);
        const textEl = document.getElementById(id + 'Text');
        const barEl = document.getElementById(id + 'Bar');
        textEl.textContent = text || 'Loading...';
        barEl.style.width = (pct || 0) + '%';
        overlay.style.display = 'flex';
    }
    function updateLoading(id, text, pct) {
        const textEl = document.getElementById(id + 'Text');
        const barEl = document.getElementById(id + 'Bar');
        if (text) textEl.textContent = text;
        barEl.style.width = Math.min(100, pct || 0) + '%';
    }
    function hideLoading(id) {
        document.getElementById(id).style.display = 'none';
    }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ===========================================================
    //  FORCE-DIRECTED LAYOUT
    // ===========================================================
    // Simple seeded PRNG (mulberry32) for deterministic layout
    function seededRng(seed) {
        let s = seed | 0;
        return function() {
            s = (s + 0x6D2B79F5) | 0;
            let t = Math.imul(s ^ (s >>> 15), 1 | s);
            t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    }

    // Segment intersection test: do segments (p1,p2) and (p3,p4) cross?
    function segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4) {
        const d1x = x2-x1, d1y = y2-y1, d2x = x4-x3, d2y = y4-y3;
        const cross = d1x*d2y - d1y*d2x;
        if (Math.abs(cross) < 1e-10) return false;
        const t = ((x3-x1)*d2y - (y3-y1)*d2x) / cross;
        const u = ((x3-x1)*d1y - (y3-y1)*d1x) / cross;
        return t > 0.01 && t < 0.99 && u > 0.01 && u < 0.99;
    }

    async function layoutGraph(graph, nodeR, onProgress) {
        const { nodes, edges } = graph;
        const keys = Array.from(nodes.keys());
        const n = keys.length;
        if (n === 0) return new Map();
        if (n === 1) return new Map([[keys[0], { x: 0, y: 0 }]]);

        // Deterministic seed from graph structure
        let seed = n * 73 + edges.length * 137;
        for (let i = 0; i < Math.min(keys.length, 8); i++) seed += keys[i].charCodeAt(0) * (i+1);
        const rng = seededRng(seed);

        const idx = new Map(); keys.forEach((k,i) => idx.set(k,i));
        const px = new Float64Array(n), py = new Float64Array(n);
        const vx = new Float64Array(n), vy = new Float64Array(n);

        // Find root node (depth 0)
        let rootIdx = 0;
        const byDepth = new Map();
        for (const [k, d] of nodes) {
            if (!byDepth.has(d.depth)) byDepth.set(d.depth, []);
            byDepth.get(d.depth).push(k);
            if (d.depth === 0) rootIdx = idx.get(k);
        }

        // Scale ring spacing with edge density for better spread
        const density = n > 1 ? edges.length / n : 0;
        const densityScale = 1 + Math.max(0, density - 1.5) * 0.6;
        const ringR = nodeR * 5 * densityScale;

        for (const [depth, ks] of byDepth) {
            for (let j = 0; j < ks.length; j++) {
                const i = idx.get(ks[j]);
                if (depth === 0) { px[i] = 0; py[i] = 0; continue; }
                const a = (j / ks.length) * 2 * Math.PI + (rng()-0.5)*0.4;
                const r = depth * ringR + (rng()-0.5)*30;
                px[i] = r * Math.cos(a); py[i] = r * Math.sin(a);
            }
        }

        // Precompute edge index pairs for the force loop (skip self-loops)
        const edgeIdx = [];
        for (const e of edges) {
            const a = idx.get(e.from), b = idx.get(e.to);
            if (a !== undefined && b !== undefined && a !== b) edgeIdx.push([a, b]);
        }

        const idealDist = (nodeR * 4 + 12 * Math.sqrt(n)) * densityScale;
        const repK = idealDist * idealDist * 2.0;
        const attK = 0.2;
        const crossK = idealDist * 0.8;   // edge-crossing repulsion strength
        const iters = n <= 20 ? 600 : n <= 60 ? 450 : n <= 150 ? 300 : 150;
        const CHUNK = 30; // yield to UI every CHUNK iterations

        for (let iter = 0; iter < iters; iter++) {
            const temp = Math.max(0.01, 1 - iter / iters);
            const maxD = Math.max(1, 80 * temp);

            // Node-node repulsion
            for (let i = 0; i < n; i++) {
                for (let j = i+1; j < n; j++) {
                    const dx = px[j]-px[i], dy = py[j]-py[i];
                    const d2 = dx*dx+dy*dy+1, d = Math.sqrt(d2);
                    const f = repK/d2, fx = dx/d*f, fy = dy/d*f;
                    vx[i] -= fx; vy[i] -= fy; vx[j] += fx; vy[j] += fy;
                }
            }

            // Edge attraction
            for (const [a, b] of edgeIdx) {
                const dx = px[b]-px[a], dy = py[b]-py[a];
                const d = Math.sqrt(dx*dx+dy*dy)+1;
                const f = attK*(d-idealDist), fx = dx/d*f, fy = dy/d*f;
                vx[a] += fx; vy[a] += fy; vx[b] -= fx; vy[b] -= fy;
            }

            // Edge-crossing repulsion: push apart nodes of crossing edges
            if (edgeIdx.length <= 500) {  // skip for very large graphs
                for (let ei = 0; ei < edgeIdx.length; ei++) {
                    const [a, b] = edgeIdx[ei];
                    for (let ej = ei+1; ej < edgeIdx.length; ej++) {
                        const [c, d] = edgeIdx[ej];
                        // Skip edges that share an endpoint
                        if (a === c || a === d || b === c || b === d) continue;
                        if (!segmentsIntersect(px[a],py[a],px[b],py[b],
                                               px[c],py[c],px[d],py[d])) continue;
                        // Push midpoints of the two edges apart
                        const mx1 = (px[a]+px[b])*0.5, my1 = (py[a]+py[b])*0.5;
                        const mx2 = (px[c]+px[d])*0.5, my2 = (py[c]+py[d])*0.5;
                        let dx = mx1-mx2, dy = my1-my2;
                        const dist = Math.sqrt(dx*dx+dy*dy)+1;
                        const strength = crossK * temp / dist;
                        dx *= strength; dy *= strength;
                        // Apply to all four endpoints (half each)
                        const h = 0.5;
                        vx[a] += dx*h; vy[a] += dy*h;
                        vx[b] += dx*h; vy[b] += dy*h;
                        vx[c] -= dx*h; vy[c] -= dy*h;
                        vx[d] -= dx*h; vy[d] -= dy*h;
                    }
                }
            }

            // Node-edge repulsion: push nodes away from non-adjacent edges
            if (n <= 200 && edgeIdx.length <= 500) {
                for (const [a, b] of edgeIdx) {
                    for (let c = 0; c < n; c++) {
                        if (c === a || c === b) continue;
                        // Closest point on segment ab to point c
                        const abx = px[b] - px[a], aby = py[b] - py[a];
                        const acx = px[c] - px[a], acy = py[c] - py[a];
                        const ab2 = abx * abx + aby * aby + 1;
                        const t = Math.max(0, Math.min(1, (acx * abx + acy * aby) / ab2));
                        const cx2 = px[a] + t * abx, cy2 = py[a] + t * aby;
                        let dx = px[c] - cx2, dy = py[c] - cy2;
                        const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                        const minDist = nodeR * 1.8;
                        if (dist < minDist) {
                            const strength = (minDist - dist) * 0.3 * temp;
                            dx = dx / dist * strength; dy = dy / dist * strength;
                            vx[c] += dx; vy[c] += dy;
                            // Push edge endpoints slightly in opposite direction
                            vx[a] -= dx * 0.15; vy[a] -= dy * 0.15;
                            vx[b] -= dx * 0.15; vy[b] -= dy * 0.15;
                        }
                    }
                }
            }

            // Apply velocities with damping and gravity
            for (let i = 0; i < n; i++) {
                const gravity = (i === rootIdx) ? 0.05 : 0.006;
                vx[i] -= px[i]*gravity*temp; vy[i] -= py[i]*gravity*temp;
                vx[i] *= 0.82; vy[i] *= 0.82;
                const sp = Math.sqrt(vx[i]*vx[i]+vy[i]*vy[i]);
                if (sp > maxD) { vx[i] = vx[i]/sp*maxD; vy[i] = vy[i]/sp*maxD; }
                px[i] += vx[i]; py[i] += vy[i];
            }

            // Yield to UI periodically so the progress bar updates
            if (onProgress && iter % CHUNK === CHUNK - 1) {
                onProgress(iter / iters);
                await sleep(0);
            }
        }

        const pos = new Map();
        for (let i = 0; i < n; i++) pos.set(keys[i], { x: px[i], y: py[i] });
        return pos;
    }

    function autoFitToCanvas(layout, nodeR, canvasEl) {
        if (!layout || layout.size === 0) return [1, 0, 0];
        let x0=Infinity, x1=-Infinity, y0=Infinity, y1=-Infinity;
        for (const p of layout.values()) {
            x0 = Math.min(x0, p.x-nodeR); x1 = Math.max(x1, p.x+nodeR);
            y0 = Math.min(y0, p.y-nodeR); y1 = Math.max(y1, p.y+nodeR);
        }
        const cw = parseFloat(canvasEl.style.width), ch = parseFloat(canvasEl.style.height);
        const w = x1-x0+80, h = y1-y0+80;
        const scale = Math.min(cw/w, ch/h, 2.5);
        const panX = -((x0+x1)/2)*scale;
        const panY = -((y0+y1)/2)*scale;
        return [scale, panX, panY];
    }

    // ===========================================================
    //  MUTATION GRAPH DRAWING
    // ===========================================================
    function drawMutationGraph() {
        const cw = parseFloat(mgCanvas.style.width) || mgCanvas.width;
        const ch = parseFloat(mgCanvas.style.height) || mgCanvas.height;
        mgCtx.clearRect(0, 0, mgCanvas.width, mgCanvas.height);
        if (!currentGraph || !currentLayout) return;

        mgCtx.save();
        mgCtx.translate(cw/2 + mgPanX, ch/2 + mgPanY);
        mgCtx.rotate(mgRotation);
        mgCtx.scale(mgScale, mgScale);

        if (currentGraph.stubs) for (const s of currentGraph.stubs) drawMGStub(s);
        for (const e of currentGraph.edges) drawMGEdge(e);
        if (currentGraph.selfLoops) for (const e of currentGraph.selfLoops) drawMGSelfLoop(e);
        for (const [key, data] of currentGraph.nodes) {
            const p = currentLayout.get(key);
            if (p) drawMGNode(p.x, p.y, data.matrix, key === currentGraph.initialKey);
        }

        mgCtx.restore();
    }

    // Draw a multi-label badge: colored circles for each label, arranged in a row
    function drawMGLabels(cx, cy, labels) {
        if (labels.length === 0) return;
        if (labels.length === 1) {
            const col = VERTEX_COLORS[labels[0]];
            mgCtx.beginPath(); mgCtx.arc(cx,cy,12,0,Math.PI*2);
            mgCtx.fillStyle='#fff'; mgCtx.fill();
            mgCtx.strokeStyle=col; mgCtx.lineWidth=1.5; mgCtx.stroke();
            mgCtx.fillStyle=col;
            mgCtx.font='bold 14px "Segoe UI",sans-serif';
            mgCtx.textAlign='center'; mgCtx.textBaseline='middle';
            mgCtx.fillText(''+(labels[0]+1),cx,cy);
            return;
        }
        // Multiple labels: draw side by side in a rounded pill
        const r = 10, gap = 20;
        const totalW = (labels.length - 1) * gap;
        const startX = cx - totalW / 2;
        // White pill background
        const pillR = 12;
        const left = startX - pillR, right = startX + totalW + pillR;
        const top = cy - pillR, bot = cy + pillR;
        mgCtx.beginPath();
        mgCtx.moveTo(left + pillR, top);
        mgCtx.arcTo(right, top, right, bot, pillR);
        mgCtx.arcTo(right, bot, left, bot, pillR);
        mgCtx.arcTo(left, bot, left, top, pillR);
        mgCtx.arcTo(left, top, right, top, pillR);
        mgCtx.closePath();
        mgCtx.fillStyle = '#fff'; mgCtx.fill();
        mgCtx.strokeStyle = '#bbb'; mgCtx.lineWidth = 1.2; mgCtx.stroke();
        // Draw each label number in its color
        mgCtx.font = 'bold 14px "Segoe UI",sans-serif';
        mgCtx.textAlign = 'center'; mgCtx.textBaseline = 'middle';
        for (let i = 0; i < labels.length; i++) {
            const lx = startX + i * gap;
            mgCtx.fillStyle = VERTEX_COLORS[labels[i]];
            mgCtx.fillText('' + (labels[i] + 1), lx, cy);
        }
    }

    function drawMGSelfLoop(e) {
        const pA = currentLayout.get(e.from);
        if (!pA) return;
        const loopR = MG_NODE_R * 0.6;
        const angle = -Math.PI / 2;
        const cx = pA.x + Math.cos(angle) * (MG_NODE_R + loopR);
        const cy = pA.y + Math.sin(angle) * (MG_NODE_R + loopR);
        // Draw loop arc in gray if multiple labels, else in the single label's color
        const lineCol = e.labels.length === 1 ? VERTEX_COLORS[e.labels[0]] : '#aaa';
        mgCtx.beginPath();
        mgCtx.arc(cx, cy, loopR, 0, Math.PI * 2);
        mgCtx.strokeStyle = lineCol; mgCtx.lineWidth = 2.5; mgCtx.stroke();
        const lx = pA.x + Math.cos(angle) * (MG_NODE_R + loopR * 2 + 10);
        const ly = pA.y + Math.sin(angle) * (MG_NODE_R + loopR * 2 + 10);
        drawMGLabels(lx, ly, e.labels);
    }

    // Visual edge: labelsA = mutations from A side, labelsB = mutations from B side.
    // Drawn as a single line with label badges.
    function drawMGEdge(e) {
        const pA = currentLayout.get(e.from), pB = currentLayout.get(e.to);
        if (!pA || !pB) return;
        const hasA = e.labelsA.length > 0, hasB = e.labelsB.length > 0;
        if (!hasA && !hasB) return;

        const dx = pB.x-pA.x, dy = pB.y-pA.y;
        const len = norm(dx,dy)+0.01;
        const ux = dx/len, uy = dy/len, px = -uy, py = ux;

        const gap = MG_NODE_R+2;
        const cpX = (pA.x+pB.x)/2, cpY = (pA.y+pB.y)/2;
        const sdx = cpX-pA.x, sdy = cpY-pA.y, sd = norm(sdx,sdy);
        const edx = pB.x-cpX, edy = pB.y-cpY, ed = norm(edx,edy);
        const sx = pA.x+sdx/sd*gap, sy = pA.y+sdy/sd*gap;
        const ex = pB.x-edx/ed*gap, ey = pB.y-edy/ed*gap;

        // All unique labels on this edge
        const allLabels = [...new Set([...e.labelsA, ...e.labelsB])].sort();
        const lineCol = allLabels.length === 1 ? VERTEX_COLORS[allLabels[0]] : '#aaa';

        mgCtx.beginPath(); mgCtx.moveTo(sx,sy); mgCtx.lineTo(ex,ey);
        mgCtx.strokeStyle = lineCol; mgCtx.lineWidth = 2.5; mgCtx.stroke();

        // Point along the edge at parameter t
        function edgePt(t) {
            return { x: sx + t*(ex-sx), y: sy + t*(ey-sy) };
        }

        // Check if both sides have the exact same set of labels
        const sameLabels = hasA && hasB && e.labelsA.length === e.labelsB.length &&
            e.labelsA.every((v,i) => v === e.labelsB[i]);

        if (sameLabels || (!hasA || !hasB)) {
            // Same labels both ways, or only one direction: single badge at midpoint
            const m = edgePt(0.5);
            drawMGLabels(m.x, m.y, hasA ? e.labelsA : e.labelsB);
        } else {
            // Different labels each way: badge near each endpoint
            const nearA = edgePt(0.28);
            const nearB = edgePt(0.72);
            drawMGLabels(nearA.x, nearA.y, e.labelsA);
            drawMGLabels(nearB.x, nearB.y, e.labelsB);
        }
    }

    function drawMGStub(s) {
        const p = currentLayout.get(s.from);
        if (!p) return;
        // find a direction away from connected neighbors
        let ax = 0, ay = 0;
        for (const e of currentGraph.edges) {
            let nb = null;
            if (e.from === s.from) nb = currentLayout.get(e.to);
            else if (e.to === s.from) nb = currentLayout.get(e.from);
            if (nb) { ax += p.x - nb.x; ay += p.y - nb.y; }
        }
        // also push away from center
        ax += p.x * 0.3; ay += p.y * 0.3;
        const al = norm(ax, ay) + 0.01;
        // add some angular spread based on label
        const baseAngle = Math.atan2(ay/al, ax/al);
        const spread = (s.label - 1) * 0.45;
        const angle = baseAngle + spread;
        const ux = Math.cos(angle), uy = Math.sin(angle);

        const stubLen = MG_NODE_R * 1.6;
        const gap = MG_NODE_R + 2;
        const sx = p.x + ux * gap, sy = p.y + uy * gap;
        const ex = p.x + ux * (gap + stubLen), ey = p.y + uy * (gap + stubLen);
        const col = VERTEX_COLORS[s.label];

        mgCtx.save();
        mgCtx.setLineDash([5, 4]);
        mgCtx.beginPath(); mgCtx.moveTo(sx, sy); mgCtx.lineTo(ex, ey);
        mgCtx.strokeStyle = col; mgCtx.lineWidth = 2; mgCtx.globalAlpha = 0.5;
        mgCtx.stroke();
        mgCtx.setLineDash([]);
        mgCtx.restore();
    }

    function drawMGNode(x, y, B, isInitial) {
        mgCtx.beginPath(); mgCtx.arc(x,y,MG_NODE_R,0,Math.PI*2);
        mgCtx.fillStyle = isInitial ? '#fffde7' : '#ffffff'; mgCtx.fill();
        mgCtx.strokeStyle = isInitial ? '#f39c12' : '#bdc3c7';
        mgCtx.lineWidth = isInitial ? 3.5 : 1.8;
        mgCtx.stroke();

        const Q = matrixToQuiver(B);
        const mr = MG_NODE_R*0.52, vr = 4.5;
        const mv = [];
        for (let i = 0; i < 3; i++) {
            const a = -Math.PI/2+i*2*Math.PI/3;
            mv.push({ x: x+mr*Math.cos(a), y: y+mr*Math.sin(a) });
        }

        const mgCenter = { x: x, y: y };
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                if (i!==j && Q[i][j]>0) drawMiniArrowOn(mgCtx, mv[i],mv[j],Q[i][j], mgCenter);

        for (let i = 0; i < 3; i++) {
            mgCtx.beginPath(); mgCtx.arc(mv[i].x,mv[i].y,vr,0,Math.PI*2);
            mgCtx.fillStyle=VERTEX_COLORS[i]; mgCtx.fill();
            mgCtx.fillStyle='#fff';
            mgCtx.font='bold 6px "Segoe UI",sans-serif';
            mgCtx.textAlign='center'; mgCtx.textBaseline='middle';
            mgCtx.fillText(''+(i+1),mv[i].x,mv[i].y+0.3);
        }
    }

    function drawMiniArrowOn(c, from, to, count, center) {
        const dx = to.x-from.x, dy = to.y-from.y, len = norm(dx,dy);
        const ux = dx/len, uy = dy/len, px = -uy, py = ux;
        const gap = 5.5;
        const sx = from.x+ux*gap, sy = from.y+uy*gap;
        const ex = to.x-ux*gap, ey = to.y-uy*gap;

        c.beginPath(); c.moveTo(sx,sy); c.lineTo(ex,ey);
        c.strokeStyle='#555'; c.lineWidth=1; c.stroke();
        arrowhead(c, ex, ey, ux, uy, 5, '#555');

        if (count > 1) {
            const midX = (sx+ex)/2, midY = (sy+ey)/2;
            // Place label on the side away from the triangle center
            let sign = 1;
            if (center) {
                const dot = (center.x - midX) * px + (center.y - midY) * py;
                if (dot > 0) sign = -1;
            }
            const mx = midX + px*5*sign, my = midY + py*5*sign;
            c.font='bold 6px "Segoe UI",sans-serif';
            c.fillStyle='#333';
            c.textAlign='center'; c.textBaseline='middle';
            c.fillText(''+count,mx,my);
        }
    }

    // ===========================================================
    //  MUTATION GRAPH UPDATE PIPELINE
    // ===========================================================
    let mgGeneration = 0;
    async function updateMutationGraph() {
        const gen = ++mgGeneration;
        sizeMGCanvas();
        showLoading('mgLoading', 'Building graph\u2026', 5);
        await sleep(0);
        if (gen !== mgGeneration) return;

        const B = quiverToMatrix(quiver);
        const depth = parseInt(document.getElementById('depthSelect').value);
        const upToPerm = document.getElementById('mgPermToggle').checked;
        currentGraph = buildMutationGraph(B, depth, upToPerm);
        if (gen !== mgGeneration) return;

        updateLoading('mgLoading', 'Computing layout\u2026', 15);
        await sleep(0);
        if (gen !== mgGeneration) return;

        currentLayout = await layoutGraph(currentGraph, MG_NODE_R, (p) => {
            if (gen === mgGeneration) updateLoading('mgLoading', 'Computing layout\u2026', 15 + p * 83);
        });
        if (gen !== mgGeneration) return;

        updateLoading('mgLoading', 'Drawing\u2026', 99);
        await sleep(0);

        const fit = autoFitToCanvas(currentLayout, MG_NODE_R, mgCanvas);
        mgScale = fit[0]; mgPanX = fit[1]; mgPanY = fit[2];
        drawMutationGraph();

        const totalEdges = currentGraph.edges.length + (currentGraph.selfLoops ? currentGraph.selfLoops.length : 0);
        let txt = currentGraph.nodes.size + ' quiver' + (currentGraph.nodes.size!==1?'s':'') +
                  ', ' + totalEdges + ' edge' + (totalEdges!==1?'s':'');
        if (currentGraph.capped) txt += ' <span class="warn">(truncated at '+MAX_GRAPH_NODES+' nodes)</span>';
        document.getElementById('mgInfo').innerHTML = txt;
        hideLoading('mgLoading');
    }

    // ===========================================================
    //  EXCHANGE GRAPH DRAWING
    // ===========================================================
    function drawExchangeGraph() {
        const cw = parseFloat(egCanvas.style.width) || egCanvas.width;
        const ch = parseFloat(egCanvas.style.height) || egCanvas.height;
        egCtx.clearRect(0, 0, egCanvas.width, egCanvas.height);
        if (!currentEGGraph || !currentEGLayout) return;
        egCtx.save();
        egCtx.translate(cw/2 + egPanX, ch/2 + egPanY);
        egCtx.rotate(egRotation);
        egCtx.scale(egScale, egScale);
        if (currentEGGraph.stubs) for (const s of currentEGGraph.stubs) drawEGStub(s);
        for (const e of currentEGGraph.edges) drawEGEdge(e);
        if (currentEGGraph.selfLoops) for (const e of currentEGGraph.selfLoops) drawEGSelfLoop(e);
        for (const [key, data] of currentEGGraph.nodes) {
            const p = currentEGLayout.get(key);
            if (p) drawEGNode(p.x, p.y, data, key === currentEGGraph.initialKey);
        }
        egCtx.restore();
    }

    // Shared label-drawing for EG (mirrors MG version but uses egCtx)
    function drawEGLabels(cx, cy, labels) {
        if (labels.length === 0) return;
        if (labels.length === 1) {
            const col = VERTEX_COLORS[labels[0]];
            egCtx.beginPath(); egCtx.arc(cx,cy,12,0,Math.PI*2);
            egCtx.fillStyle='#fff'; egCtx.fill();
            egCtx.strokeStyle=col; egCtx.lineWidth=1.5; egCtx.stroke();
            egCtx.fillStyle=col;
            egCtx.font='bold 14px "Segoe UI",sans-serif';
            egCtx.textAlign='center'; egCtx.textBaseline='middle';
            egCtx.fillText(''+(labels[0]+1),cx,cy);
            return;
        }
        const gap = 20, pillR = 12;
        const totalW = (labels.length - 1) * gap;
        const startX = cx - totalW / 2;
        const left = startX - pillR, right = startX + totalW + pillR;
        const top = cy - pillR, bot = cy + pillR;
        egCtx.beginPath();
        egCtx.moveTo(left + pillR, top);
        egCtx.arcTo(right, top, right, bot, pillR);
        egCtx.arcTo(right, bot, left, bot, pillR);
        egCtx.arcTo(left, bot, left, top, pillR);
        egCtx.arcTo(left, top, right, top, pillR);
        egCtx.closePath();
        egCtx.fillStyle = '#fff'; egCtx.fill();
        egCtx.strokeStyle = '#bbb'; egCtx.lineWidth = 1.2; egCtx.stroke();
        egCtx.font = 'bold 14px "Segoe UI",sans-serif';
        egCtx.textAlign = 'center'; egCtx.textBaseline = 'middle';
        for (let i = 0; i < labels.length; i++) {
            egCtx.fillStyle = VERTEX_COLORS[labels[i]];
            egCtx.fillText('' + (labels[i] + 1), startX + i * gap, cy);
        }
    }

    function drawEGSelfLoop(e) {
        const pA = currentEGLayout.get(e.from);
        if (!pA) return;
        const loopR = EG_NODE_R * 0.45;
        const angle = -Math.PI / 2;
        const cx = pA.x + Math.cos(angle) * (EG_NODE_R + loopR);
        const cy = pA.y + Math.sin(angle) * (EG_NODE_R + loopR);
        const lineCol = e.labels.length === 1 ? VERTEX_COLORS[e.labels[0]] : '#aaa';
        egCtx.beginPath();
        egCtx.arc(cx, cy, loopR, 0, Math.PI * 2);
        egCtx.strokeStyle = lineCol; egCtx.lineWidth = 2.5; egCtx.stroke();
        const lx = pA.x + Math.cos(angle) * (EG_NODE_R + loopR * 2 + 10);
        const ly = pA.y + Math.sin(angle) * (EG_NODE_R + loopR * 2 + 10);
        drawEGLabels(lx, ly, e.labels);
    }

    function drawEGEdge(e) {
        const pA = currentEGLayout.get(e.from), pB = currentEGLayout.get(e.to);
        if (!pA || !pB) return;
        const hasA = e.labelsA.length > 0, hasB = e.labelsB.length > 0;
        if (!hasA && !hasB) return;

        const dx = pB.x-pA.x, dy = pB.y-pA.y;
        const len = norm(dx,dy)+0.01;
        const ux = dx/len, uy = dy/len, px = -uy, py = ux;
        const gap = EG_NODE_R+2;
        const cpX = (pA.x+pB.x)/2, cpY = (pA.y+pB.y)/2;
        const sdx = cpX-pA.x, sdy = cpY-pA.y, sd = norm(sdx,sdy);
        const edx = pB.x-cpX, edy = pB.y-cpY, ed = norm(edx,edy);
        const sx = pA.x+sdx/sd*gap, sy = pA.y+sdy/sd*gap;
        const ex = pB.x-edx/ed*gap, ey = pB.y-edy/ed*gap;

        const allLabels = [...new Set([...e.labelsA, ...e.labelsB])].sort();
        const lineCol = allLabels.length === 1 ? VERTEX_COLORS[allLabels[0]] : '#aaa';

        egCtx.beginPath(); egCtx.moveTo(sx,sy); egCtx.lineTo(ex,ey);
        egCtx.strokeStyle = lineCol; egCtx.lineWidth = 2.5; egCtx.stroke();

        function edgePt(t) {
            return { x: sx + t*(ex-sx), y: sy + t*(ey-sy) };
        }

        const sameLabels = hasA && hasB && e.labelsA.length === e.labelsB.length &&
            e.labelsA.every((v,i) => v === e.labelsB[i]);

        if (sameLabels || (!hasA || !hasB)) {
            const m = edgePt(0.5);
            drawEGLabels(m.x, m.y, hasA ? e.labelsA : e.labelsB);
        } else {
            const nearA = edgePt(0.28);
            const nearB = edgePt(0.72);
            drawEGLabels(nearA.x, nearA.y, e.labelsA);
            drawEGLabels(nearB.x, nearB.y, e.labelsB);
        }
    }

    function drawEGStub(s) {
        const p = currentEGLayout.get(s.from);
        if (!p) return;
        let ax = 0, ay = 0;
        for (const e of currentEGGraph.edges) {
            let nb = null;
            if (e.from === s.from) nb = currentEGLayout.get(e.to);
            else if (e.to === s.from) nb = currentEGLayout.get(e.from);
            if (nb) { ax += p.x - nb.x; ay += p.y - nb.y; }
        }
        ax += p.x * 0.3; ay += p.y * 0.3;
        const al = norm(ax, ay) + 0.01;
        const baseAngle = Math.atan2(ay/al, ax/al);
        const spread = (s.label - 1) * 0.45;
        const angle = baseAngle + spread;
        const ux = Math.cos(angle), uy = Math.sin(angle);
        const stubLen = EG_NODE_R * 1.2;
        const gap = EG_NODE_R + 2;
        const sx = p.x + ux * gap, sy = p.y + uy * gap;
        const ex = p.x + ux * (gap + stubLen), ey = p.y + uy * (gap + stubLen);
        const col = VERTEX_COLORS[s.label];
        egCtx.save();
        egCtx.setLineDash([5, 4]);
        egCtx.beginPath(); egCtx.moveTo(sx, sy); egCtx.lineTo(ex, ey);
        egCtx.strokeStyle = col; egCtx.lineWidth = 2; egCtx.globalAlpha = 0.5;
        egCtx.stroke(); egCtx.setLineDash([]); egCtx.restore();
    }

    function roundedRect(c, x, y, w, h, r) {
        c.beginPath();
        c.moveTo(x+r, y); c.lineTo(x+w-r, y);
        c.arcTo(x+w, y, x+w, y+r, r);
        c.lineTo(x+w, y+h-r);
        c.arcTo(x+w, y+h, x+w-r, y+h, r);
        c.lineTo(x+r, y+h);
        c.arcTo(x, y+h, x, y+h-r, r);
        c.lineTo(x, y+r);
        c.arcTo(x, y, x+r, y, r);
        c.closePath();
    }

    function drawEGNode(x, y, data, isInitial) {
        const w2 = EG_NODE_W/2, h2 = EG_NODE_H/2;
        roundedRect(egCtx, x-w2, y-h2, EG_NODE_W, EG_NODE_H, 8);
        egCtx.fillStyle = isInitial ? '#fffde7' : '#ffffff'; egCtx.fill();
        egCtx.strokeStyle = isInitial ? '#f39c12' : '#bdc3c7';
        egCtx.lineWidth = isInitial ? 3 : 1.5; egCtx.stroke();

        // Mini quiver in upper portion
        const Q = matrixToQuiver(data.matrix);
        const qy = y - h2 + 28;
        const mr = 16, vr = 3.5;
        const mv = [];
        for (let i = 0; i < 3; i++) {
            const a = -Math.PI/2 + i*2*Math.PI/3;
            mv.push({ x: x + mr*Math.cos(a), y: qy + mr*Math.sin(a) });
        }
        const egCenter = { x: x, y: qy };
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                if (i!==j && Q[i][j]>0) drawMiniArrowOn(egCtx, mv[i], mv[j], Q[i][j], egCenter);
        for (let i = 0; i < 3; i++) {
            egCtx.beginPath(); egCtx.arc(mv[i].x, mv[i].y, vr, 0, Math.PI*2);
            egCtx.fillStyle = VERTEX_COLORS[i]; egCtx.fill();
            egCtx.fillStyle = '#fff';
            egCtx.font = 'bold 5px "Segoe UI",sans-serif';
            egCtx.textAlign = 'center'; egCtx.textBaseline = 'middle';
            egCtx.fillText(''+(i+1), mv[i].x, mv[i].y+0.3);
        }

        // Separator line
        const sepY = y - h2 + 52;
        egCtx.beginPath(); egCtx.moveTo(x-w2+6, sepY); egCtx.lineTo(x+w2-6, sepY);
        egCtx.strokeStyle = '#e0e0e0'; egCtx.lineWidth = 0.5; egCtx.stroke();

        // Cluster variables
        egCtx.textAlign = 'left'; egCtx.textBaseline = 'middle';
        const startY = sepY + 11;
        const lineH = 13;
        const textW = EG_NODE_W - 22; // available width for text
        for (let i = 0; i < 3; i++) {
            const cy = startY + i * lineH;
            egCtx.beginPath(); egCtx.arc(x-w2+10, cy, 2.5, 0, Math.PI*2);
            egCtx.fillStyle = VERTEX_COLORS[i]; egCtx.fill();
            let expr = egSpecialize ? String(lpEvalAtOne(data.cluster[i])) : lpToString(data.cluster[i]);
            // auto-size font to fit, with a floor
            let fontSize = 7;
            egCtx.font = fontSize + 'px "Segoe UI",system-ui,sans-serif';
            let measured = egCtx.measureText(expr).width;
            if (measured > textW) {
                fontSize = Math.max(4, Math.floor(fontSize * textW / measured));
                egCtx.font = fontSize + 'px "Segoe UI",system-ui,sans-serif';
                measured = egCtx.measureText(expr).width;
            }
            if (measured > textW) {
                // still too long after shrinking  truncate
                while (expr.length > 1 && egCtx.measureText(expr + '\u2026').width > textW) {
                    expr = expr.slice(0, -1);
                }
                expr += '\u2026';
            }
            egCtx.fillStyle = '#333';
            egCtx.fillText(expr, x-w2+16, cy);
        }
    }

    // ===========================================================
    //  EXCHANGE GRAPH UPDATE PIPELINE
    // ===========================================================
    let egGeneration = 0;
    async function updateExchangeGraph() {
        const gen = ++egGeneration;
        sizeEGCanvas();
        showLoading('egLoading', 'Building graph\u2026', 5);
        await sleep(0);
        if (gen !== egGeneration) return;

        const B = quiverToMatrix(quiver);
        const depth = parseInt(document.getElementById('egDepthSelect').value);
        const egUpToPerm = document.getElementById('egPermToggle').checked;
        egSpecialize = document.getElementById('egSpecToggle').checked;
        currentEGGraph = buildExchangeGraph(B, depth, egUpToPerm, egSpecialize);
        if (gen !== egGeneration) return;

        updateLoading('egLoading', 'Computing layout\u2026', 15);
        await sleep(0);
        if (gen !== egGeneration) return;

        currentEGLayout = await layoutGraph(currentEGGraph, EG_NODE_R, (p) => {
            if (gen === egGeneration) updateLoading('egLoading', 'Computing layout\u2026', 15 + p * 83);
        });
        if (gen !== egGeneration) return;

        updateLoading('egLoading', 'Drawing\u2026', 99);
        await sleep(0);

        const fit = autoFitToCanvas(currentEGLayout, EG_NODE_R, egCanvas);
        egScale = fit[0]; egPanX = fit[1]; egPanY = fit[2];
        drawExchangeGraph();
        const egTotalEdges = currentEGGraph.edges.length + (currentEGGraph.selfLoops ? currentEGGraph.selfLoops.length : 0);
        let txt = currentEGGraph.nodes.size + ' seed' + (currentEGGraph.nodes.size!==1?'s':'') +
                  ', ' + egTotalEdges + ' edge' + (egTotalEdges!==1?'s':'');
        if (currentEGGraph.capped) txt += ' <span class="warn">(truncated at '+MAX_GRAPH_NODES+' nodes)</span>';
        document.getElementById('egInfo').innerHTML = txt;
        hideLoading('egLoading');
    }

    // ===========================================================
    //  ZOOM & PAN
    // ===========================================================
    mgCanvas.addEventListener('wheel', function(ev) {
        ev.preventDefault();
        const rect = mgCanvas.getBoundingClientRect();
        const cw = parseFloat(mgCanvas.style.width), ch = parseFloat(mgCanvas.style.height);
        const mx = ev.clientX-rect.left, my = ev.clientY-rect.top;
        const wx = (mx-cw/2-mgPanX)/mgScale, wy = (my-ch/2-mgPanY)/mgScale;
        const factor = Math.exp(-ev.deltaY*0.002);
        mgScale = Math.max(0.03, Math.min(8, mgScale*factor));
        mgPanX = mx-cw/2-wx*mgScale;
        mgPanY = my-ch/2-wy*mgScale;
        drawMutationGraph();
    }, { passive: false });

    mgCanvas.addEventListener('mousedown', function(ev) {
        mgDragging = true;
        mgDragX = ev.clientX; mgDragY = ev.clientY;
        mgDragPanX = mgPanX; mgDragPanY = mgPanY;
    });
    window.addEventListener('mousemove', function(ev) {
        if (!mgDragging) return;
        mgPanX = mgDragPanX+(ev.clientX-mgDragX);
        mgPanY = mgDragPanY+(ev.clientY-mgDragY);
        drawMutationGraph();
    });
    window.addEventListener('mouseup', function() { mgDragging = false; });

    // -- mutation graph touch (pan + pinch-zoom) --
    let mgPinchDist = 0;
    mgCanvas.addEventListener('touchstart', function(ev) {
        ev.preventDefault();
        if (ev.touches.length === 1) {
            const t = ev.touches[0];
            mgDragging = true;
            mgDragX = t.clientX; mgDragY = t.clientY;
            mgDragPanX = mgPanX; mgDragPanY = mgPanY;
        } else if (ev.touches.length === 2) {
            mgDragging = false;
            const dx = ev.touches[0].clientX - ev.touches[1].clientX;
            const dy = ev.touches[0].clientY - ev.touches[1].clientY;
            mgPinchDist = Math.sqrt(dx*dx + dy*dy);
        }
    }, { passive: false });
    mgCanvas.addEventListener('touchmove', function(ev) {
        ev.preventDefault();
        if (ev.touches.length === 1 && mgDragging) {
            const t = ev.touches[0];
            mgPanX = mgDragPanX + (t.clientX - mgDragX);
            mgPanY = mgDragPanY + (t.clientY - mgDragY);
            drawMutationGraph();
        } else if (ev.touches.length === 2 && mgPinchDist > 0) {
            const dx = ev.touches[0].clientX - ev.touches[1].clientX;
            const dy = ev.touches[0].clientY - ev.touches[1].clientY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const ratio = dist / mgPinchDist;
            const rect = mgCanvas.getBoundingClientRect();
            const cw = parseFloat(mgCanvas.style.width), ch = parseFloat(mgCanvas.style.height);
            const cx = (ev.touches[0].clientX + ev.touches[1].clientX) / 2 - rect.left;
            const cy = (ev.touches[0].clientY + ev.touches[1].clientY) / 2 - rect.top;
            const wx = (cx - cw/2 - mgPanX) / mgScale;
            const wy = (cy - ch/2 - mgPanY) / mgScale;
            mgScale = Math.max(0.03, Math.min(8, mgScale * ratio));
            mgPanX = cx - cw/2 - wx * mgScale;
            mgPanY = cy - ch/2 - wy * mgScale;
            mgPinchDist = dist;
            drawMutationGraph();
        }
    }, { passive: false });
    mgCanvas.addEventListener('touchend', function(ev) {
        ev.preventDefault();
        mgDragging = false;
        mgPinchDist = 0;
    }, { passive: false });

    // -- exchange graph zoom & pan --
    egCanvas.addEventListener('wheel', function(ev) {
        ev.preventDefault();
        const rect = egCanvas.getBoundingClientRect();
        const cw = parseFloat(egCanvas.style.width), ch = parseFloat(egCanvas.style.height);
        const mx = ev.clientX-rect.left, my = ev.clientY-rect.top;
        const wx = (mx-cw/2-egPanX)/egScale, wy = (my-ch/2-egPanY)/egScale;
        const factor = Math.exp(-ev.deltaY*0.002);
        egScale = Math.max(0.03, Math.min(8, egScale*factor));
        egPanX = mx-cw/2-wx*egScale; egPanY = my-ch/2-wy*egScale;
        drawExchangeGraph();
    }, { passive: false });
    egCanvas.addEventListener('mousedown', function(ev) {
        egDragging = true; egDragX = ev.clientX; egDragY = ev.clientY;
        egDragPanX = egPanX; egDragPanY = egPanY;
    });
    window.addEventListener('mousemove', function(ev) {
        if (!egDragging) return;
        egPanX = egDragPanX+(ev.clientX-egDragX);
        egPanY = egDragPanY+(ev.clientY-egDragY);
        drawExchangeGraph();
    });
    window.addEventListener('mouseup', function() { egDragging = false; });

    // -- exchange graph touch (pan + pinch-zoom) --
    let egPinchDist = 0;
    egCanvas.addEventListener('touchstart', function(ev) {
        ev.preventDefault();
        if (ev.touches.length === 1) {
            const t = ev.touches[0];
            egDragging = true;
            egDragX = t.clientX; egDragY = t.clientY;
            egDragPanX = egPanX; egDragPanY = egPanY;
        } else if (ev.touches.length === 2) {
            egDragging = false;
            const dx = ev.touches[0].clientX - ev.touches[1].clientX;
            const dy = ev.touches[0].clientY - ev.touches[1].clientY;
            egPinchDist = Math.sqrt(dx*dx + dy*dy);
        }
    }, { passive: false });
    egCanvas.addEventListener('touchmove', function(ev) {
        ev.preventDefault();
        if (ev.touches.length === 1 && egDragging) {
            const t = ev.touches[0];
            egPanX = egDragPanX + (t.clientX - egDragX);
            egPanY = egDragPanY + (t.clientY - egDragY);
            drawExchangeGraph();
        } else if (ev.touches.length === 2 && egPinchDist > 0) {
            const dx = ev.touches[0].clientX - ev.touches[1].clientX;
            const dy = ev.touches[0].clientY - ev.touches[1].clientY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const ratio = dist / egPinchDist;
            const rect = egCanvas.getBoundingClientRect();
            const cw = parseFloat(egCanvas.style.width), ch = parseFloat(egCanvas.style.height);
            const cx = (ev.touches[0].clientX + ev.touches[1].clientX) / 2 - rect.left;
            const cy = (ev.touches[0].clientY + ev.touches[1].clientY) / 2 - rect.top;
            const wx = (cx - cw/2 - egPanX) / egScale;
            const wy = (cy - ch/2 - egPanY) / egScale;
            egScale = Math.max(0.03, Math.min(8, egScale * ratio));
            egPanX = cx - cw/2 - wx * egScale;
            egPanY = cy - ch/2 - wy * egScale;
            egPinchDist = dist;
            drawExchangeGraph();
        }
    }, { passive: false });
    egCanvas.addEventListener('touchend', function(ev) {
        ev.preventDefault();
        egDragging = false;
        egPinchDist = 0;
    }, { passive: false });

    // -- exchange graph tooltip --
    const egTooltip = document.getElementById('egTooltip');
    let egTooltipKey = null;
    let egTooltipPinned = false;

    function egScreenToWorld(sx, sy) {
        const rect = egCanvas.getBoundingClientRect();
        const cw = parseFloat(egCanvas.style.width), ch = parseFloat(egCanvas.style.height);
        let x = (sx - rect.left) - cw/2 - egPanX;
        let y = (sy - rect.top) - ch/2 - egPanY;
        const c = Math.cos(-egRotation), s = Math.sin(-egRotation);
        const rx = x*c - y*s, ry = x*s + y*c;
        return { x: rx/egScale, y: ry/egScale };
    }

    function egHitTest(sx, sy) {
        if (!currentEGGraph || !currentEGLayout) return null;
        const w = egScreenToWorld(sx, sy);
        const hw = EG_NODE_W/2, hh = EG_NODE_H/2;
        for (const [key, data] of currentEGGraph.nodes) {
            const p = currentEGLayout.get(key);
            if (!p) continue;
            if (w.x >= p.x-hw && w.x <= p.x+hw && w.y >= p.y-hh && w.y <= p.y+hh) {
                return { key, data };
            }
        }
        return null;
    }

    function egBuildTooltipHTML(data) {
        const colors = ['#3498db','#e74c3c','#27ae60'];
        let html = '';
        for (let i = 0; i < 3; i++) {
            const expr = egSpecialize ? String(lpEvalAtOne(data.cluster[i])) : lpToString(data.cluster[i]);
            html += '<div class="tt-var">'
                  + '<span class="tt-dot" style="background:'+colors[i]+'"></span>'
                  + '<span class="tt-expr">x' + SUB[i] + ' = ' + expr + '</span></div>';
        }
        html += '<div class="tt-hint">click to pin &amp; copy</div>';
        return html;
    }

    function egDismissTooltip() {
        egTooltip.style.display = 'none';
        egTooltip.classList.remove('pinned');
        egTooltipKey = null;
        egTooltipPinned = false;
    }

    egCanvas.addEventListener('mousemove', function(ev) {
        if (egDragging || egTooltipPinned) return;
        const hit = egHitTest(ev.clientX, ev.clientY);
        if (!hit) {
            if (egTooltipKey) egDismissTooltip();
            return;
        }
        if (hit.key !== egTooltipKey) {
            egTooltipKey = hit.key;
            egTooltip.innerHTML = egBuildTooltipHTML(hit.data);
            egTooltip.style.display = 'block';
        }
        egTooltip.style.left = (ev.clientX + 14) + 'px';
        egTooltip.style.top = (ev.clientY + 14) + 'px';
    });

    egCanvas.addEventListener('click', function(ev) {
        if (egTooltipPinned) { egDismissTooltip(); return; }
        const hit = egHitTest(ev.clientX, ev.clientY);
        if (!hit) return;
        egTooltipKey = hit.key;
        egTooltipPinned = true;
        egTooltip.innerHTML = egBuildTooltipHTML(hit.data);
        egTooltip.classList.add('pinned');
        egTooltip.style.display = 'block';
        egTooltip.style.left = (ev.clientX + 14) + 'px';
        egTooltip.style.top = (ev.clientY + 14) + 'px';
    });

    egCanvas.addEventListener('mouseleave', function() {
        if (!egTooltipPinned) egDismissTooltip();
    });

    document.addEventListener('keydown', function(ev) {
        if (ev.key === 'Escape' && egTooltipPinned) egDismissTooltip();
    });
    document.addEventListener('mousedown', function(ev) {
        if (egTooltipPinned && !egTooltip.contains(ev.target) && ev.target !== egCanvas) {
            egDismissTooltip();
        }
    });

    // ===========================================================
    //  SCATTERING GRAPH  VECTOR MATH
    // ===========================================================
    function wedge(w, v) { return w[0] * v[1] - w[1] * v[0]; }

    function muV(v, w) {
        const d = Math.min(wedge(w, v), 0);
        return [w[0] + d * v[0], w[1] + d * v[1]];
    }

    function muVInv(v, w) {
        const d = Math.min(wedge(w, v), 0);
        return [w[0] - d * v[0], w[1] - d * v[1]];
    }

    function scatterMutate(triple, k) {
        const vk = triple[k];
        return triple.map((v, i) => {
            if (i === k) return [-v[0], -v[1]];
            return muV(vk, v);
        });
    }

    function computeBaseMap(triple, path) {
        let T = triple.map(v => [v[0], v[1]]);
        for (let s = path.length - 1; s >= 0; s--) {
            const ik = path[s];
            const neg_v = [-T[ik][0], -T[ik][1]];
            T = T.map(w => muVInv(neg_v, w));
        }
        return T;
    }

    function sgTripleKey(T) {
        return T.map(v => v[0] + ',' + v[1]).join('|');
    }
    function sgCanonicalTripleKey(T) {
        const perms = [
            [0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]
        ];
        let best = null;
        for (const p of perms) {
            const k = T[p[0]][0]+','+T[p[0]][1]+'|'+T[p[1]][0]+','+T[p[1]][1]+'|'+T[p[2]][0]+','+T[p[2]][1];
            if (best === null || k < best) best = k;
        }
        return best;
    }

    function quiverToRays(B) {
        // Derive Z vectors v1,v2,v3 with det(vi,vj) = B[i][j]
        if (B[0][1] !== 0) {
            const v1 = [1, 0];
            const v2 = [0, B[0][1]];
            if (B[1][2] % B[0][1] === 0) {
                const v3 = [-B[1][2] / B[0][1], B[0][2]];
                return [v1, v2, v3];
            }
        }
        if (B[0][2] !== 0) {
            const v1 = [1, 0];
            const v3 = [0, B[0][2]];
            if (B[1][2] % B[0][2] === 0) {
                const v2 = [B[1][2] / B[0][2], B[0][1]];
                return [v1, v2, v3];
            }
        }
        if (B[1][2] !== 0) {
            const v2 = [1, 0];
            const v3 = [0, B[1][2]];
            const v1 = [0, 0]; // det(v1,v2)=B[0][1]  v1[1]=B[0][1]; det(v1,v3)=B[0][2]  v1[0]*B[1][2]=B[0][2]
            v1[1] = B[0][1];
            if (B[1][2] !== 0 && B[0][2] % B[1][2] === 0) {
                v1[0] = B[0][2] / B[1][2];
                return [v1, v2, v3];
            }
        }
        // Fallback: zero quiver
        return [[1, 0], [0, 1], [-1, -1]];
    }

    // ===========================================================
    //  SCATTERING GRAPH  BFS CONSTRUCTION
    // ===========================================================
    function buildScatteringGraph(initialRays, maxDepth, upToPermutation) {
        const keyFn = upToPermutation ? sgCanonicalTripleKey : sgTripleKey;
        const nodes = new Map();
        const edgeSet = new Set();
        const rawEdges = [];
        const rawSelfLoops = [];

        const initBM = computeBaseMap(initialRays, []);
        const ik = keyFn(initBM);
        nodes.set(ik, { triple: initialRays.map(v => [v[0], v[1]]), path: [], baseMap: initBM, depth: 0 });
        let frontier = [ik];
        let capped = false;

        for (let d = 0; d < maxDepth; d++) {
            const next = [];
            for (const key of frontier) {
                const nd = nodes.get(key);
                const lastMut = nd.path.length > 0 ? nd.path[nd.path.length - 1] : -1;
                for (let k = 0; k < 3; k++) {
                    if (k === lastMut) continue; // no consecutive repeats
                    const newTriple = scatterMutate(nd.triple, k);
                    const newPath = nd.path.concat(k);
                    const newBM = computeBaseMap(newTriple, newPath);
                    const nk = keyFn(newBM);

                    if (nk === key) {
                        rawSelfLoops.push({ node: key, label: k });
                        continue;
                    }

                    const ek1 = key + '>' + nk + '|' + k;
                    const ek2 = nk + '>' + key + '|' + k;
                    if (!edgeSet.has(ek1)) {
                        edgeSet.add(ek1); edgeSet.add(ek2);
                    }
                    rawEdges.push({ from: key, to: nk, label: k });

                    if (!nodes.has(nk)) {
                        if (nodes.size >= MAX_GRAPH_NODES) { capped = true; continue; }
                        nodes.set(nk, { triple: newTriple, path: newPath, baseMap: newBM, depth: d + 1 });
                        next.push(nk);
                    }
                }
            }
            frontier = next;
        }

        // Boundary edges from frontier into known nodes
        for (const key of frontier) {
            const nd = nodes.get(key);
            const lastMut = nd.path.length > 0 ? nd.path[nd.path.length - 1] : -1;
            for (let k = 0; k < 3; k++) {
                if (k === lastMut) continue;
                const newTriple = scatterMutate(nd.triple, k);
                const newPath = nd.path.concat(k);
                const newBM = computeBaseMap(newTriple, newPath);
                const nk = keyFn(newBM);
                if (!nodes.has(nk)) continue;
                rawEdges.push({ from: key, to: nk, label: k });
            }
        }

        // Stubs for unexplored frontier edges
        const stubs = [];
        for (const key of frontier) {
            const nd = nodes.get(key);
            const lastMut = nd.path.length > 0 ? nd.path[nd.path.length - 1] : -1;
            for (let k = 0; k < 3; k++) {
                if (k === lastMut) continue;
                const newTriple = scatterMutate(nd.triple, k);
                const newPath = nd.path.concat(k);
                const newBM = computeBaseMap(newTriple, newPath);
                const nk = keyFn(newBM);
                if (!nodes.has(nk)) {
                    stubs.push({ from: key, label: k });
                }
            }
        }

        // Consolidate raw edges into visual edges with labelsA/labelsB
        const pairMap = new Map();
        const selfLoopMap = new Map();
        for (const e of rawEdges) {
            if (e.from === e.to) {
                if (!selfLoopMap.has(e.from)) selfLoopMap.set(e.from, []);
                selfLoopMap.get(e.from).push(e.label);
                continue;
            }
            const aKey = e.from < e.to ? e.from : e.to;
            const bKey = e.from < e.to ? e.to : e.from;
            const pk = aKey + '||' + bKey;
            if (!pairMap.has(pk)) pairMap.set(pk, { a: aKey, b: bKey, labelsA: [], labelsB: [] });
            const p = pairMap.get(pk);
            if (e.from === p.a) { if (!p.labelsA.includes(e.label)) p.labelsA.push(e.label); }
            else { if (!p.labelsB.includes(e.label)) p.labelsB.push(e.label); }
        }
        for (const e of rawSelfLoops) {
            if (!selfLoopMap.has(e.node)) selfLoopMap.set(e.node, []);
            const arr = selfLoopMap.get(e.node);
            if (!arr.includes(e.label)) arr.push(e.label);
        }
        const edges = [];
        for (const p of pairMap.values()) {
            edges.push({ from: p.a, to: p.b, labelsA: p.labelsA.sort(), labelsB: p.labelsB.sort() });
        }
        const selfLoops = [];
        for (const [nodeKey, labels] of selfLoopMap) {
            selfLoops.push({ from: nodeKey, labels: labels.sort() });
        }

        return { nodes, edges, selfLoops, stubs, initialKey: ik, capped };
    }

    // ===========================================================
    //  SCATTERING GRAPH  DRAWING
    // ===========================================================
    const EDGE_COLORS_SG = ['#3498db', '#e74c3c', '#27ae60'];

    function drawSGNode(x, y, data, isInitial) {
        const w2 = SG_NODE_W / 2, h2 = SG_NODE_H / 2;
        roundedRect(sgCtx, x - w2, y - h2, SG_NODE_W, SG_NODE_H, 8);
        sgCtx.fillStyle = isInitial ? '#fffde7' : '#fff';
        sgCtx.fill();
        sgCtx.lineWidth = isInitial ? 3 : 1.5;
        sgCtx.strokeStyle = isInitial ? '#f39c12' : '#bdc3c7';
        sgCtx.stroke();

        // Draw 3 base-mapped vectors as arrows in upper portion
        const bm = data.baseMap;
        const arrowCX = x, arrowCY = y - h2 + 28;
        const arrowR = 22;
        let maxComp = 1;
        for (const v of bm) { maxComp = Math.max(maxComp, Math.abs(v[0]), Math.abs(v[1])); }
        const scale = arrowR / maxComp;

        for (let i = 0; i < 3; i++) {
            const vx = bm[i][0] * scale, vy = -bm[i][1] * scale;
            const len = Math.sqrt(vx * vx + vy * vy);
            if (len < 1) continue;
            sgCtx.beginPath();
            sgCtx.moveTo(arrowCX, arrowCY);
            sgCtx.lineTo(arrowCX + vx, arrowCY + vy);
            sgCtx.strokeStyle = EDGE_COLORS_SG[i];
            sgCtx.lineWidth = 2;
            sgCtx.stroke();
            if (len > 6) {
                const ux = vx / len, uy = vy / len;
                const ax = arrowCX + vx, ay = arrowCY + vy;
                const ah = 4;
                sgCtx.beginPath();
                sgCtx.moveTo(ax, ay);
                sgCtx.lineTo(ax - ux * ah + uy * ah * 0.5, ay - uy * ah - ux * ah * 0.5);
                sgCtx.lineTo(ax - ux * ah - uy * ah * 0.5, ay - uy * ah + ux * ah * 0.5);
                sgCtx.closePath();
                sgCtx.fillStyle = EDGE_COLORS_SG[i];
                sgCtx.fill();
            }
        }

        // Separator line
        const sepY = y - h2 + 52;
        sgCtx.beginPath();
        sgCtx.moveTo(x - w2 + 6, sepY);
        sgCtx.lineTo(x + w2 - 6, sepY);
        sgCtx.strokeStyle = '#e0e0e0';
        sgCtx.lineWidth = 0.5;
        sgCtx.stroke();

        // Vector labels below separator
        const labels = ['v\u2081', 'v\u2082', 'v\u2083'];
        const startY = sepY + 11;
        const lineH = 13;
        const textW = SG_NODE_W - 22;
        sgCtx.textAlign = 'left';
        sgCtx.textBaseline = 'middle';
        for (let i = 0; i < 3; i++) {
            const cy = startY + i * lineH;
            sgCtx.beginPath();
            sgCtx.arc(x - w2 + 10, cy, 2.5, 0, Math.PI * 2);
            sgCtx.fillStyle = EDGE_COLORS_SG[i];
            sgCtx.fill();
            const expr = labels[i] + ' = (' + bm[i][0] + ', ' + bm[i][1] + ')';
            let fontSize = 7;
            sgCtx.font = fontSize + 'px "Segoe UI",system-ui,sans-serif';
            let measured = sgCtx.measureText(expr).width;
            if (measured > textW) {
                fontSize = Math.max(4, Math.floor(fontSize * textW / measured));
                sgCtx.font = fontSize + 'px "Segoe UI",system-ui,sans-serif';
            }
            sgCtx.fillStyle = '#333';
            sgCtx.fillText(expr, x - w2 + 16, cy);
        }
    }

    function drawSGLabels(cx, cy, labels) {
        if (labels.length === 0) return;
        if (labels.length === 1) {
            const col = EDGE_COLORS_SG[labels[0]];
            sgCtx.beginPath(); sgCtx.arc(cx, cy, 12, 0, Math.PI * 2);
            sgCtx.fillStyle = '#fff'; sgCtx.fill();
            sgCtx.strokeStyle = col; sgCtx.lineWidth = 1.5; sgCtx.stroke();
            sgCtx.fillStyle = col;
            sgCtx.font = 'bold 14px "Segoe UI",sans-serif';
            sgCtx.textAlign = 'center'; sgCtx.textBaseline = 'middle';
            sgCtx.fillText('' + (labels[0] + 1), cx, cy);
            return;
        }
        const gap = 20;
        const totalW = (labels.length - 1) * gap;
        const startX = cx - totalW / 2;
        const pillR = 12;
        const left = startX - pillR, right = startX + totalW + pillR;
        const top = cy - pillR, bot = cy + pillR;
        sgCtx.beginPath();
        sgCtx.moveTo(left + pillR, top);
        sgCtx.arcTo(right, top, right, bot, pillR);
        sgCtx.arcTo(right, bot, left, bot, pillR);
        sgCtx.arcTo(left, bot, left, top, pillR);
        sgCtx.arcTo(left, top, right, top, pillR);
        sgCtx.closePath();
        sgCtx.fillStyle = '#fff'; sgCtx.fill();
        sgCtx.strokeStyle = '#bbb'; sgCtx.lineWidth = 1.2; sgCtx.stroke();
        sgCtx.font = 'bold 14px "Segoe UI",sans-serif';
        sgCtx.textAlign = 'center'; sgCtx.textBaseline = 'middle';
        for (let i = 0; i < labels.length; i++) {
            sgCtx.fillStyle = EDGE_COLORS_SG[labels[i]];
            sgCtx.fillText('' + (labels[i] + 1), startX + i * gap, cy);
        }
    }

    function drawSGEdge(e) {
        const pA = currentSGLayout.get(e.from), pB = currentSGLayout.get(e.to);
        if (!pA || !pB) return;
        const hasA = e.labelsA.length > 0, hasB = e.labelsB.length > 0;
        if (!hasA && !hasB) return;

        const dx = pB.x - pA.x, dy = pB.y - pA.y;
        const len = norm(dx, dy) + 0.01;
        const gap = SG_NODE_R + 2;
        const cpX = (pA.x + pB.x) / 2, cpY = (pA.y + pB.y) / 2;
        const sdx = cpX - pA.x, sdy = cpY - pA.y, sd = norm(sdx, sdy);
        const edx = pB.x - cpX, edy = pB.y - cpY, ed = norm(edx, edy);
        const sx = pA.x + sdx / sd * gap, sy = pA.y + sdy / sd * gap;
        const ex = pB.x - edx / ed * gap, ey = pB.y - edy / ed * gap;

        const allLabels = [...new Set([...e.labelsA, ...e.labelsB])].sort();
        const lineCol = allLabels.length === 1 ? EDGE_COLORS_SG[allLabels[0]] : '#aaa';

        sgCtx.beginPath(); sgCtx.moveTo(sx, sy); sgCtx.lineTo(ex, ey);
        sgCtx.strokeStyle = lineCol; sgCtx.lineWidth = 2.5; sgCtx.stroke();

        function edgePt(t) { return { x: sx + t * (ex - sx), y: sy + t * (ey - sy) }; }

        const sameLabels = hasA && hasB && e.labelsA.length === e.labelsB.length &&
            e.labelsA.every((v, i) => v === e.labelsB[i]);

        if (sameLabels || (!hasA || !hasB)) {
            const m = edgePt(0.5);
            drawSGLabels(m.x, m.y, hasA ? e.labelsA : e.labelsB);
        } else {
            const nearA = edgePt(0.28);
            const nearB = edgePt(0.72);
            drawSGLabels(nearA.x, nearA.y, e.labelsA);
            drawSGLabels(nearB.x, nearB.y, e.labelsB);
        }
    }

    function drawSGSelfLoop(e) {
        const pA = currentSGLayout.get(e.from);
        if (!pA) return;
        const loopR = SG_NODE_R * 0.4;
        const angle = -Math.PI / 2;
        const cx = pA.x + Math.cos(angle) * (SG_NODE_R + loopR);
        const cy = pA.y + Math.sin(angle) * (SG_NODE_R + loopR);
        const lineCol = e.labels.length === 1 ? EDGE_COLORS_SG[e.labels[0]] : '#aaa';
        sgCtx.beginPath();
        sgCtx.arc(cx, cy, loopR, 0, Math.PI * 2);
        sgCtx.strokeStyle = lineCol; sgCtx.lineWidth = 2.5; sgCtx.stroke();
        const lx = pA.x + Math.cos(angle) * (SG_NODE_R + loopR * 2 + 10);
        const ly = pA.y + Math.sin(angle) * (SG_NODE_R + loopR * 2 + 10);
        drawSGLabels(lx, ly, e.labels);
    }

    function drawSGStub(s) {
        const p = currentSGLayout.get(s.from);
        if (!p) return;
        // Draw short stub outward
        let angle = 0, count = 0;
        for (const [key, data] of currentSGGraph.nodes) {
            const pp = currentSGLayout.get(key);
            if (pp && key !== s.from) { angle += Math.atan2(pp.y - p.y, pp.x - p.x); count++; }
        }
        const away = count > 0 ? (angle / count + Math.PI) : s.label * Math.PI * 2 / 3;
        const stubLen = 20;
        const sx = p.x + Math.cos(away) * SG_NODE_R;
        const sy = p.y + Math.sin(away) * SG_NODE_R;
        sgCtx.beginPath();
        sgCtx.moveTo(sx, sy);
        sgCtx.lineTo(sx + Math.cos(away) * stubLen, sy + Math.sin(away) * stubLen);
        sgCtx.strokeStyle = EDGE_COLORS_SG[s.label];
        sgCtx.lineWidth = 2;
        sgCtx.setLineDash([4, 4]);
        sgCtx.stroke();
        sgCtx.setLineDash([]);
    }

    function drawScatteringGraph() {
        const cw = parseFloat(sgCanvas.style.width) || sgCanvas.width;
        const ch = parseFloat(sgCanvas.style.height) || sgCanvas.height;
        sgCtx.clearRect(0, 0, sgCanvas.width, sgCanvas.height);
        if (!currentSGGraph || !currentSGLayout) return;

        sgCtx.save();
        sgCtx.translate(cw / 2 + sgPanX, ch / 2 + sgPanY);
        sgCtx.rotate(sgRotation);
        sgCtx.scale(sgScale, sgScale);

        if (currentSGGraph.stubs) for (const s of currentSGGraph.stubs) drawSGStub(s);
        for (const e of currentSGGraph.edges) drawSGEdge(e);
        if (currentSGGraph.selfLoops) for (const e of currentSGGraph.selfLoops) drawSGSelfLoop(e);
        for (const [key, data] of currentSGGraph.nodes) {
            const p = currentSGLayout.get(key);
            if (p) drawSGNode(p.x, p.y, data, key === currentSGGraph.initialKey);
        }

        sgCtx.restore();
    }

    // ===========================================================
    //  SCATTERING GRAPH  ASYNC UPDATE
    // ===========================================================
    let sgGeneration = 0;
    async function updateScatteringGraph() {
        const gen = ++sgGeneration;
        sizeSGCanvas();
        showLoading('sgLoading', 'Building graph\u2026', 5);
        await sleep(0);
        if (gen !== sgGeneration) return;

        const rays = (getQuiverType() === 'scatter')
            ? customVectors.map(v => [v[0], v[1]])
            : quiverToRays(quiverToMatrix(quiver));
        const depth = parseInt(document.getElementById('sgDepthSelect').value);
        const sgUpToPerm = document.getElementById('sgPermToggle').checked;
        currentSGGraph = buildScatteringGraph(rays, depth, sgUpToPerm);
        if (gen !== sgGeneration) return;

        updateLoading('sgLoading', 'Computing layout\u2026', 15);
        await sleep(0);
        if (gen !== sgGeneration) return;

        currentSGLayout = await layoutGraph(currentSGGraph, SG_NODE_R, (p) => {
            if (gen === sgGeneration) updateLoading('sgLoading', 'Computing layout\u2026', 15 + p * 83);
        });
        if (gen !== sgGeneration) return;

        updateLoading('sgLoading', 'Drawing\u2026', 99);
        await sleep(0);

        const fit = autoFitToCanvas(currentSGLayout, SG_NODE_R, sgCanvas);
        sgScale = fit[0]; sgPanX = fit[1]; sgPanY = fit[2];
        drawScatteringGraph();

        const totalEdges = currentSGGraph.edges.length + currentSGGraph.selfLoops.length;
        let txt = currentSGGraph.nodes.size + ' node' + (currentSGGraph.nodes.size !== 1 ? 's' : '') +
                  ', ' + totalEdges + ' edge' + (totalEdges !== 1 ? 's' : '');
        if (currentSGGraph.capped) txt += ' <span class="warn">(truncated at ' + MAX_GRAPH_NODES + ' nodes)</span>';
        document.getElementById('sgInfo').innerHTML = txt;
        hideLoading('sgLoading');
    }

    // ===========================================================
    //  SCATTERING GRAPH  ZOOM, PAN, TOUCH
    // ===========================================================
    sgCanvas.addEventListener('wheel', function(ev) {
        ev.preventDefault();
        const rect = sgCanvas.getBoundingClientRect();
        const cw = parseFloat(sgCanvas.style.width), ch = parseFloat(sgCanvas.style.height);
        const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
        const wx = (mx - cw / 2 - sgPanX) / sgScale, wy = (my - ch / 2 - sgPanY) / sgScale;
        const factor = Math.exp(-ev.deltaY * 0.002);
        sgScale = Math.max(0.03, Math.min(8, sgScale * factor));
        sgPanX = mx - cw / 2 - wx * sgScale;
        sgPanY = my - ch / 2 - wy * sgScale;
        drawScatteringGraph();
    }, { passive: false });

    sgCanvas.addEventListener('mousedown', function(ev) {
        sgDragging = true;
        sgDragX = ev.clientX; sgDragY = ev.clientY;
        sgDragPanX = sgPanX; sgDragPanY = sgPanY;
    });
    window.addEventListener('mousemove', function(ev) {
        if (!sgDragging) return;
        sgPanX = sgDragPanX + (ev.clientX - sgDragX);
        sgPanY = sgDragPanY + (ev.clientY - sgDragY);
        drawScatteringGraph();
    });
    window.addEventListener('mouseup', function() { sgDragging = false; });

    let sgPinchDist = 0;
    sgCanvas.addEventListener('touchstart', function(ev) {
        ev.preventDefault();
        if (ev.touches.length === 1) {
            const t = ev.touches[0];
            sgDragging = true;
            sgDragX = t.clientX; sgDragY = t.clientY;
            sgDragPanX = sgPanX; sgDragPanY = sgPanY;
        } else if (ev.touches.length === 2) {
            sgDragging = false;
            const dx = ev.touches[0].clientX - ev.touches[1].clientX;
            const dy = ev.touches[0].clientY - ev.touches[1].clientY;
            sgPinchDist = Math.sqrt(dx * dx + dy * dy);
        }
    }, { passive: false });
    sgCanvas.addEventListener('touchmove', function(ev) {
        ev.preventDefault();
        if (ev.touches.length === 1 && sgDragging) {
            const t = ev.touches[0];
            sgPanX = sgDragPanX + (t.clientX - sgDragX);
            sgPanY = sgDragPanY + (t.clientY - sgDragY);
            drawScatteringGraph();
        } else if (ev.touches.length === 2 && sgPinchDist > 0) {
            const dx = ev.touches[0].clientX - ev.touches[1].clientX;
            const dy = ev.touches[0].clientY - ev.touches[1].clientY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const ratio = dist / sgPinchDist;
            const rect = sgCanvas.getBoundingClientRect();
            const cw = parseFloat(sgCanvas.style.width), ch = parseFloat(sgCanvas.style.height);
            const cx = (ev.touches[0].clientX + ev.touches[1].clientX) / 2 - rect.left;
            const cy = (ev.touches[0].clientY + ev.touches[1].clientY) / 2 - rect.top;
            const wx = (cx - cw / 2 - sgPanX) / sgScale;
            const wy = (cy - ch / 2 - sgPanY) / sgScale;
            sgScale = Math.max(0.03, Math.min(8, sgScale * ratio));
            sgPanX = cx - cw / 2 - wx * sgScale;
            sgPanY = cy - ch / 2 - wy * sgScale;
            sgPinchDist = dist;
            drawScatteringGraph();
        }
    }, { passive: false });
    sgCanvas.addEventListener('touchend', function(ev) {
        ev.preventDefault();
        sgDragging = false;
        sgPinchDist = 0;
    }, { passive: false });

    // ===========================================================
    //  SCATTERING GRAPH  TOOLTIP
    // ===========================================================
    const sgTooltip = document.getElementById('sgTooltip');
    let sgTooltipKey = null;
    let sgTooltipPinned = false;

    function sgScreenToWorld(sx, sy) {
        const rect = sgCanvas.getBoundingClientRect();
        const cw = parseFloat(sgCanvas.style.width), ch = parseFloat(sgCanvas.style.height);
        let x = (sx - rect.left) - cw / 2 - sgPanX;
        let y = (sy - rect.top) - ch / 2 - sgPanY;
        const c = Math.cos(-sgRotation), s = Math.sin(-sgRotation);
        const rx = x * c - y * s, ry = x * s + y * c;
        return { x: rx / sgScale, y: ry / sgScale };
    }

    function sgHitTest(sx, sy) {
        if (!currentSGGraph || !currentSGLayout) return null;
        const w = sgScreenToWorld(sx, sy);
        const hw = SG_NODE_W / 2, hh = SG_NODE_H / 2;
        for (const [key, data] of currentSGGraph.nodes) {
            const p = currentSGLayout.get(key);
            if (!p) continue;
            if (w.x >= p.x - hw && w.x <= p.x + hw && w.y >= p.y - hh && w.y <= p.y + hh) {
                return { key, data };
            }
        }
        return null;
    }

    function sgBuildTooltipHTML(data) {
        const colors = ['#3498db', '#e74c3c', '#27ae60'];
        const labels = ['v\u2081', 'v\u2082', 'v\u2083'];
        let html = '';
        for (let i = 0; i < 3; i++) {
            const v = data.baseMap[i];
            html += '<div class="tt-var">'
                  + '<span class="tt-dot" style="background:' + colors[i] + '"></span>'
                  + '<span class="tt-expr">' + labels[i] + ' = (' + v[0] + ', ' + v[1] + ')</span></div>';
        }
        html += '<div class="tt-hint">click to pin</div>';
        return html;
    }

    function sgDismissTooltip() {
        sgTooltip.style.display = 'none';
        sgTooltip.classList.remove('pinned');
        sgTooltipKey = null;
        sgTooltipPinned = false;
    }

    sgCanvas.addEventListener('mousemove', function(ev) {
        if (sgDragging || sgTooltipPinned) return;
        const hit = sgHitTest(ev.clientX, ev.clientY);
        if (!hit) { if (sgTooltipKey) sgDismissTooltip(); return; }
        if (hit.key !== sgTooltipKey) {
            sgTooltipKey = hit.key;
            sgTooltip.innerHTML = sgBuildTooltipHTML(hit.data);
            sgTooltip.style.display = 'block';
        }
        sgTooltip.style.left = (ev.clientX + 14) + 'px';
        sgTooltip.style.top = (ev.clientY + 14) + 'px';
    });
    sgCanvas.addEventListener('click', function(ev) {
        if (sgTooltipPinned) { sgDismissTooltip(); return; }
        const hit = sgHitTest(ev.clientX, ev.clientY);
        if (!hit) return;
        sgTooltipKey = hit.key;
        sgTooltipPinned = true;
        sgTooltip.innerHTML = sgBuildTooltipHTML(hit.data);
        sgTooltip.classList.add('pinned');
        sgTooltip.style.display = 'block';
        sgTooltip.style.left = (ev.clientX + 14) + 'px';
        sgTooltip.style.top = (ev.clientY + 14) + 'px';
    });
    sgCanvas.addEventListener('mouseleave', function() {
        if (!sgTooltipPinned) sgDismissTooltip();
    });
    document.addEventListener('keydown', function(ev) {
        if (ev.key === 'Escape' && sgTooltipPinned) sgDismissTooltip();
    });
    document.addEventListener('mousedown', function(ev) {
        if (sgTooltipPinned && !sgTooltip.contains(ev.target) && ev.target !== sgCanvas) {
            sgDismissTooltip();
        }
    });

    // ===========================================================
    //  INIT
    // ===========================================================
    document.querySelectorAll('input[name="quiverType"]').forEach(r => r.addEventListener('change', applyQuiverSelection));
    document.getElementById('applyVectorsBtn').addEventListener('click', applyVectorTriple);
    document.getElementById('randomizeBtn').addEventListener('click', generateRandomQuiver);
    document.getElementById('depthSelect').addEventListener('change', () => {
        if (document.getElementById('tabMG').classList.contains('active')) {
            updateMutationGraph();
        } else { mgNeedsRebuild = true; }
    });
    document.getElementById('mgPermToggle').addEventListener('change', () => {
        if (document.getElementById('tabMG').classList.contains('active')) {
            updateMutationGraph();
        } else { mgNeedsRebuild = true; }
    });
    document.getElementById('egDepthSelect').addEventListener('change', () => {
        if (document.getElementById('tabEG').classList.contains('active')) {
            updateExchangeGraph();
        } else { egNeedsRebuild = true; }
    });
    document.getElementById('egPermToggle').addEventListener('change', () => {
        if (document.getElementById('tabEG').classList.contains('active')) {
            updateExchangeGraph();
        } else { egNeedsRebuild = true; }
    });
    document.getElementById('egSpecToggle').addEventListener('change', () => {
        if (document.getElementById('tabEG').classList.contains('active')) {
            updateExchangeGraph();
        } else { egNeedsRebuild = true; }
    });
    document.getElementById('mgRotate').addEventListener('input', function() {
        mgRotation = this.value * Math.PI / 180;
        document.getElementById('mgAngleLabel').innerHTML = this.value + '&deg;';
        drawMutationGraph();
    });
    document.getElementById('egRotate').addEventListener('input', function() {
        egRotation = this.value * Math.PI / 180;
        document.getElementById('egAngleLabel').innerHTML = this.value + '&deg;';
        drawExchangeGraph();
    });
    document.getElementById('sgDepthSelect').addEventListener('change', () => {
        if (document.getElementById('tabSG').classList.contains('active')) {
            updateScatteringGraph();
        } else { sgNeedsRebuild = true; }
    });
    document.getElementById('sgPermToggle').addEventListener('change', () => {
        if (document.getElementById('tabSG').classList.contains('active')) {
            updateScatteringGraph();
        } else { sgNeedsRebuild = true; }
    });
    document.getElementById('sgRotate').addEventListener('input', function() {
        sgRotation = this.value * Math.PI / 180;
        document.getElementById('sgAngleLabel').innerHTML = this.value + '&deg;';
        drawScatteringGraph();
    });
    // ===========================================================
    //  EXPORT (shared for MG, EG, and SG)
    // ===========================================================
    function setupExportPopover(btnId, popoverId, containerId) {
        const btn = document.getElementById(btnId);
        const pop = document.getElementById(popoverId);
        btn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            pop.style.display = pop.style.display === 'none' ? 'block' : 'none';
        });
        // Close popover when clicking outside
        document.addEventListener('mousedown', (ev) => {
            if (pop.style.display !== 'none' &&
                !document.getElementById(containerId).contains(ev.target)) {
                pop.style.display = 'none';
            }
        });
    }
    setupExportPopover('mgExportBtn', 'mgExportPopover', 'mgExportContainer');
    setupExportPopover('egExportBtn', 'egExportPopover', 'egExportContainer');
    setupExportPopover('sgExportBtn', 'sgExportPopover', 'sgExportContainer');

    function renderHighRes(canvas, ctx, drawFn, scale) {
        const dpr = window.devicePixelRatio || 1;
        const cssW = parseFloat(canvas.style.width);
        const cssH = parseFloat(canvas.style.height);
        const origPxW = canvas.width, origPxH = canvas.height;

        // Resize and re-render at requested scale
        canvas.width = Math.round(cssW * scale);
        canvas.height = Math.round(cssH * scale);
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
        drawFn();

        // Capture with white background
        const offscreen = document.createElement('canvas');
        offscreen.width = canvas.width; offscreen.height = canvas.height;
        const oCtx = offscreen.getContext('2d');
        oCtx.fillStyle = '#ffffff';
        oCtx.fillRect(0, 0, offscreen.width, offscreen.height);
        oCtx.drawImage(canvas, 0, 0);

        // Restore original canvas
        canvas.width = origPxW; canvas.height = origPxH;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        drawFn();

        return { offscreen, cssW, cssH };
    }

    function doExportPdf(offscreen, cssW, cssH, filename) {
        function go() {
            const { jsPDF } = window.jspdf;
            const imgData = offscreen.toDataURL('image/png');
            const landscape = cssW >= cssH;
            const doc = new jsPDF({ orientation: landscape ? 'landscape' : 'portrait', unit: 'pt', format: [cssW, cssH] });
            doc.addImage(imgData, 'PNG', 0, 0, cssW, cssH);
            doc.save(filename);
        }
        if (window.jspdf) { go(); return; }
        const s = document.createElement('script');
        s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        s.onload = go;
        s.onerror = function() { alert('Could not load PDF library. Check your internet connection.'); };
        document.head.appendChild(s);
    }

    function doExportPng(offscreen, filename) {
        const link = document.createElement('a');
        link.download = filename;
        link.href = offscreen.toDataURL('image/png');
        link.click();
    }

    function handleExport(prefix, canvas, ctx, drawFn, filenameBase) {
        const fmt = document.querySelector('input[name="'+prefix+'Fmt"]:checked').value;
        const scale = parseInt(document.querySelector('input[name="'+prefix+'Res"]:checked').value);
        const pop = document.getElementById(prefix + 'ExportPopover');
        pop.style.display = 'none';

        const btn = document.getElementById(prefix + 'ExportBtn');
        btn.textContent = 'Exporting\u2026'; btn.disabled = true;

        // Use setTimeout to let UI update before heavy rendering
        setTimeout(() => {
            const { offscreen, cssW, cssH } = renderHighRes(canvas, ctx, drawFn, scale);
            if (fmt === 'pdf') {
                doExportPdf(offscreen, cssW, cssH, filenameBase + '.pdf');
            } else {
                doExportPng(offscreen, filenameBase + '.png');
            }
            btn.textContent = 'Export'; btn.disabled = false;
        }, 50);
    }

    document.getElementById('mgExportGo').addEventListener('click', () => {
        if (!currentGraph || !currentLayout) return;
        handleExport('mg', mgCanvas, mgCtx, drawMutationGraph, 'mutation_graph');
    });
    document.getElementById('egExportGo').addEventListener('click', () => {
        if (!currentEGGraph || !currentEGLayout) return;
        handleExport('eg', egCanvas, egCtx, drawExchangeGraph, 'exchange_graph');
    });
    document.getElementById('sgExportGo').addEventListener('click', () => {
        if (!currentSGGraph || !currentSGLayout) return;
        handleExport('sg', sgCanvas, sgCtx, drawScatteringGraph, 'scattering_graph');
    });

    // Default: vector triple quiver
    sizeQuiverCanvas();
    applyVectorTriple();
    </script>
</body>
</html>
